
==================== FINAL INTERFACE ====================
2016-07-28 16:38:09.394278 UTC

interface main@main:ConnectN 7103
  interface hash: fba369d8eed331d9b86c050450b26527
  ABI hash: e73c9a5d0d75d7c0c8ad67cb95a33de2
  export-list hash: 0a3d4a613aebca4b8e3b133289a92166
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 1ba42ae73d0b95f43952688546ccbfaa
  sig of: Nothing
  used TH splices: False
  where
exports:
  ConnectN.epsilons
  ConnectN.height
  ConnectN.main
  ConnectN.movesToBoard
  ConnectN.optimalOutcome
  ConnectN.optimalPlay
  ConnectN.p
  ConnectN.pPar
  ConnectN.parEpsilons
  ConnectN.parOptimalPlay
  ConnectN.prettyPrint
  ConnectN.takeTurn
  ConnectN.value
  ConnectN.width
  ConnectN.winningAmount
  ConnectN.wins
  ConnectN.Board
  ConnectN.Coordinate
  ConnectN.Move
  ConnectN.Player{ConnectN.O ConnectN.X}
  ConnectN.Position
  ConnectN.R
module dependencies: GameLogic
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0 containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 parallel-3.2.1.0@paral_BEbrIfHgHtmEpYU5TfKWK9
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Control.Exception e9090e246fba030faecf7b81b3e8e320
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Enum debc6de3086023a15993ab0cecffb90b
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Read b423b4506a014855edbd329b567629f3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:System.IO 0248c1e850b7ea124cf7a2e1669ebf67
import  -/  deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59:Control.DeepSeq 269ef0c8d019d01c547937e1ae8fb2e8
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  GameLogic 0b53a799af830780d41d4547bedd253d
  exports: 317b64144625346fcdfb42c1fb88af54
  J d7de4bb8c2cf07d476f757e42c973f23
  arginf 6448a2634243deffcacaba082e5fe765
  argsup 9b4c5776011bd1723817c8e55e621728
  bigotimes 0390703f8b24ec89a7aaa580f2c54eac
  contained d3ce28d6f34202b7ce13b3322a468b40
  setMinus 4ad413d40cc9382bca94a4a68753d099
import  -/  parallel-3.2.1.0@paral_BEbrIfHgHtmEpYU5TfKWK9:Control.Parallel 1b43eb56445614e8fc63261d7d1b82ab
import  -/  parallel-3.2.1.0@paral_BEbrIfHgHtmEpYU5TfKWK9:Control.Parallel.Strategies e559e49e970aa71559d76fa817ccb0ac
b00cfd8d035162fa92ab0b7b3611ee52
  $fEqPlayer :: GHC.Classes.Eq ConnectN.Player
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ConnectN.Player
                  ConnectN.$fEqPlayer_$c==
                  ConnectN.$fEqPlayer_$c/= -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fEqPlayer_$c/= ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: ConnectN.Player b :: ConnectN.Player ->
                 case a1 of wild {
                   ConnectN.X
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.False ConnectN.O -> GHC.Types.True }
                   ConnectN.O
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.True ConnectN.O -> GHC.Types.False } }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fEqPlayer_$c== ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: ConnectN.Player ds1 :: ConnectN.Player ->
                 case ds of wild {
                   ConnectN.X
                   -> case ds1 of wild1 {
                        ConnectN.X -> GHC.Types.True ConnectN.O -> GHC.Types.False }
                   ConnectN.O
                   -> case ds1 of wild1 {
                        ConnectN.X -> GHC.Types.False ConnectN.O -> GHC.Types.True } }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fOrdPlayer :: GHC.Classes.Ord ConnectN.Player
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ConnectN.Player
                  ConnectN.$fEqPlayer
                  ConnectN.$fOrdPlayer_$ccompare
                  ConnectN.$fOrdPlayer_$c<
                  ConnectN.$fOrdPlayer_$c<=
                  ConnectN.$fOrdPlayer_$c>
                  ConnectN.$fOrdPlayer_$c>=
                  ConnectN.$fOrdPlayer_$cmax
                  ConnectN.$fOrdPlayer_$cmin -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fOrdPlayer_$c< ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: ConnectN.Player b :: ConnectN.Player ->
                 case a1 of wild {
                   ConnectN.X
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.False ConnectN.O -> GHC.Types.True }
                   ConnectN.O -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fOrdPlayer_$c<= ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: ConnectN.Player b :: ConnectN.Player ->
                 case a1 of wild {
                   ConnectN.X -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   ConnectN.O
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.False ConnectN.O -> GHC.Types.True } }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fOrdPlayer_$c> ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: ConnectN.Player b :: ConnectN.Player ->
                 case a1 of wild {
                   ConnectN.X -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   ConnectN.O
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.True ConnectN.O -> GHC.Types.False } }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fOrdPlayer_$c>= ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: ConnectN.Player b :: ConnectN.Player ->
                 case a1 of wild {
                   ConnectN.X
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.True ConnectN.O -> GHC.Types.False }
                   ConnectN.O -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fOrdPlayer_$ccompare ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: ConnectN.Player b :: ConnectN.Player ->
                 case a1 of wild {
                   ConnectN.X
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.EQ ConnectN.O -> GHC.Types.LT }
                   ConnectN.O
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.GT ConnectN.O -> GHC.Types.EQ } }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fOrdPlayer_$cmax ::
    ConnectN.Player -> ConnectN.Player -> ConnectN.Player
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x1 :: ConnectN.Player y :: ConnectN.Player ->
                 case x1 of wild {
                   ConnectN.X -> y
                   ConnectN.O -> case y of wild1 { DEFAULT -> ConnectN.O } }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fOrdPlayer_$cmin ::
    ConnectN.Player -> ConnectN.Player -> ConnectN.Player
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x1 :: ConnectN.Player y :: ConnectN.Player ->
                 case x1 of wild {
                   ConnectN.X -> case y of wild1 { DEFAULT -> ConnectN.X }
                   ConnectN.O -> y }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer :: GHC.Read.Read ConnectN.Player
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ConnectN.Player
                  ConnectN.$fReadPlayer_$s$dmreadsPrec
                  ConnectN.$fReadPlayer_$sreadListDefault
                  ConnectN.$fReadPlayer_$creadPrec
                  ConnectN.$fReadPlayer_$creadListPrec -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([ConnectN.Player] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [ConnectN.Player] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ ConnectN.Player
                   ConnectN.$fReadPlayer2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <ConnectN.Player>_R))
                   @ b
                   eta1) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (ConnectN.Player -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: ConnectN.Player -> Text.ParserCombinators.ReadP.P b ->
                 eta ConnectN.X) -}
df157d8d09343247225c2c79cc7b4615
  $fReadPlayer11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "X"#) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP ConnectN.Player
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ ConnectN.Player
                   ConnectN.$fReadPlayer3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <ConnectN.Player>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <ConnectN.Player>_R)))) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (ConnectN.Player -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: ConnectN.Player -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ ConnectN.Player
                   ConnectN.$fReadPlayer4
                   eta
                   @ b
                   eta1) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player)
                   ConnectN.$fReadPlayer9
                   ConnectN.$fReadPlayer5) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player)
                   ConnectN.$fReadPlayer6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player))) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player)
  {- Strictness: m,
     Unfolding: ((ConnectN.$fReadPlayer8,
                  ConnectN.$fReadPlayer7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <ConnectN.Player>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <ConnectN.Player>_R))))) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (ConnectN.Player -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: ConnectN.Player -> Text.ParserCombinators.ReadP.P b ->
                 eta ConnectN.O) -}
6e6d975ae9f719bef576edaadaf3bac3
  $fReadPlayer8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "O"#) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player)
  {- Strictness: m,
     Unfolding: ((ConnectN.$fReadPlayer11,
                  ConnectN.$fReadPlayer10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <ConnectN.Player>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <ConnectN.Player>_R))))) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [ConnectN.Player]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                ConnectN.$fReadPlayer1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[ConnectN.Player]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[ConnectN.Player]>_R))) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                ConnectN.$fReadPlayer2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <ConnectN.Player>_R)) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer_$s$dmreadsPrec ::
    GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS ConnectN.Player
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ ConnectN.Player
                   ConnectN.$fReadPlayer_$creadPrec
                   eta) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [ConnectN.Player]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [ConnectN.Player]
                   ((ConnectN.$fReadPlayer_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[ConnectN.Player]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <[ConnectN.Player]>_R)
                      @ [ConnectN.Player]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [ConnectN.Player]))) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fShowPlayer :: GHC.Show.Show ConnectN.Player
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ConnectN.Player
                  ConnectN.$fShowPlayer_$cshowsPrec
                  ConnectN.$fShowPlayer_$cshow
                  ConnectN.$fShowPlayer_$cshowList -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fShowPlayer1 :: ConnectN.Player -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: ConnectN.Player eta :: GHC.Base.String ->
                 case ds of wild {
                   ConnectN.X
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n1 :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n1 ConnectN.$fReadPlayer11)
                        eta
                   ConnectN.O
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n1 :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n1 ConnectN.$fReadPlayer8)
                        eta }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fShowPlayer_$cshow :: ConnectN.Player -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x1 :: ConnectN.Player ->
                 case x1 of wild {
                   ConnectN.X -> ConnectN.$fReadPlayer11
                   ConnectN.O -> ConnectN.$fReadPlayer8 }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fShowPlayer_$cshowList :: [ConnectN.Player] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ ConnectN.Player
                   ConnectN.$fShowPlayer1) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fShowPlayer_$cshowsPrec ::
    GHC.Types.Int -> ConnectN.Player -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: ConnectN.Player
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   ConnectN.X
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n1 :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n1 ConnectN.$fReadPlayer11)
                        eta
                   ConnectN.O
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n1 :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n1 ConnectN.$fReadPlayer8)
                        eta }) -}
8ab2f7189bfdfd0edf502c77ff262072
  $wgo :: GHC.Prim.Int# -> (# [ConnectN.Move], [[ConnectN.Move]] #)
  {- Arity: 1, Strictness: <L,U>, Inline: [0] -}
fa62adba1264b8063c73bc165e1fb47c
  $wisBlank ::
    GHC.Prim.Int#
    -> ConnectN.Coordinate
    -> GHC.Prim.Int#
    -> ConnectN.Coordinate
    -> GHC.Base.Maybe ConnectN.Player
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: ConnectN.Coordinate
                   ww2 :: GHC.Prim.Int#
                   ww3 :: ConnectN.Coordinate
                   ww4 :: GHC.Base.Maybe ConnectN.Player ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Types.I# x1 ->
                      case ww3 of wild2 { GHC.Types.I# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x1 y) of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> Data.Maybe.isNothing @ ConnectN.Player ww4 } } } }) -}
addbb15bd850c9389bc219ff1d9b5d76
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
d0723843267ae3fb54ce6a38672e8439
  $wvalue :: ConnectN.Board -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ w :: ConnectN.Board ->
                 case ConnectN.wins ConnectN.X w of wild {
                   GHC.Types.False
                   -> case ConnectN.wins ConnectN.O w of wild1 {
                        GHC.Types.False -> 0 GHC.Types.True -> (-1) }
                   GHC.Types.True -> 1 }) -}
d8557d99d23f9bf5761f18f0531b5fb7
  $wxs :: GHC.Prim.Int# -> [GHC.Types.Int]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
2cfa72c50dd009bcaaa9dc9beb8b2632
  $wxs1 :: GHC.Prim.Int# -> [GHC.Types.Int]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
f2e6c97c65c59ae733bbacc46a96ba6f
  $wxs2 :: GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
8ba9f8d9b52b8d95c01a73222092b027
  type Board = [ConnectN.Position]
4d1d7819425bf78b182ecd6aa5eb83dc
  type Coordinate = GHC.Types.Int
f6732f5e1ddc64e1de69ae471e9e69e2
  type Move = GHC.Types.Int
b00cfd8d035162fa92ab0b7b3611ee52
  data Player = X | O
    Promotable
9fe7319436b125d9657b8899a12a6d0c
  type Position =
    (ConnectN.Coordinate, ConnectN.Coordinate, ConnectN.Player)
35e85e55bd7532d12206eff38fd7f9f6
  type R = GHC.Types.Int
90c1838025c6ed710e923b3a23e6b12f
  epsilons ::
    [[ConnectN.Move] -> GameLogic.J ConnectN.R ConnectN.Move]
  {- Unfolding: (GHC.List.$wunsafeTake
                   @ ([ConnectN.Move] -> GameLogic.J ConnectN.R ConnectN.Move)
                   9
                   ConnectN.epsilons_all) -}
2218df98a7dcfb95e093d6ae31c75702
  epsilons1 ::
    [[GHC.Types.Int] -> GameLogic.J GHC.Types.Int GHC.Types.Int]
  {- Strictness: m2 -}
8e7e8312641cbbbeefc8da999363adec
  epsilons2 :: [GHC.Types.Int]
  {- Unfolding: (ConnectN.$wxs 3) -}
527981515b6af8f4629a75a6bf25cf77
  epsilons_all ::
    [[GHC.Types.Int] -> GameLogic.J GHC.Types.Int GHC.Types.Int]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ([GHC.Types.Int] -> GameLogic.J GHC.Types.Int GHC.Types.Int)
                   ConnectN.epsilons_epsilonX
                   ConnectN.epsilons1) -}
45a3c8dad616e4641b8372cf849343e5
  epsilons_epsilonX ::
    [GHC.Types.Int] -> GameLogic.J GHC.Types.Int GHC.Types.Int
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ h :: [GHC.Types.Int] ->
                 GameLogic.argsup
                   @ GHC.Types.Int
                   (GameLogic.epsilons_go h ConnectN.epsilons_poolOfMoves)) -}
d1403f167117484e481488b99614ed61
  epsilons_poolOfMoves :: [GHC.Types.Int]
  {- Unfolding: (Data.OldList.sortBy
                   @ GHC.Types.Int
                   GHC.Classes.compareInt
                   ConnectN.epsilons2) -}
0010dc974ab3dda6a147413e30e4b060
  height :: GHC.Types.Int
  {- Strictness: m, Unfolding: (ConnectN.winningAmount) -}
75725ef2e33f5cff22800b9a15e577f7
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                ConnectN.main1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
36c6db4156213f66dc7f775d5463ddb1
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        ConnectN.main6
                        GHC.Types.True
                        s of ds1 { (#,#) ipv ipv1 ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   ConnectN.main2
                   GHC.Types.True
                   ipv }) -}
c3a799e2779b6e23cd376072cad8ea9e
  main10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "x"#
                   ConnectN.main11) -}
f45182f5f4269d501e81f38d2e7fa444
  main11 :: [GHC.Types.Char]
  {- Unfolding: (case GHC.Show.$wshowSignedInt
                        0
                        3
                        (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                   ConnectN.main12 }) -}
7224733bfbf68f174e67287929ef6176
  main12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " grid;"#) -}
07b0f4389f133057c332a01ed9f8fa79
  main2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "X "#
                   ConnectN.main3) -}
81badc031bbd5a4b3ed08d1807255d5d
  main3 :: [GHC.Types.Char]
  {- Unfolding: (case ConnectN.$wvalue ConnectN.main5 of ww {
                   DEFAULT -> GHC.CString.unpackAppendCString# "lose"# ConnectN.main_n
                   0 -> GHC.CString.unpackAppendCString# "draw"# ConnectN.main_n
                   1 -> GHC.CString.unpackAppendCString# "win"# ConnectN.main_n }) -}
b757b895452d5643e6f6d1f990416f26
  main4 :: GHC.Base.String
  {- Unfolding: (GHC.Show.showList__
                   @ GHC.Types.Int
                   GHC.Show.shows7
                   ConnectN.main_optimalMoves
                   (GHC.Types.[] @ GHC.Types.Char)) -}
27e6f7c5e44bd937589b41d6562184d4
  main5 :: ConnectN.Board
  {- Unfolding: (ConnectN.movesToBoard_go
                   ConnectN.movesToBoard_players
                   ConnectN.main_optimalMoves
                   (GHC.Types.[] @ ConnectN.Position)) -}
b56f93c2986bca950fabb4ba307a8899
  main6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "For a game of Connect"#
                   ConnectN.main7) -}
cc7b8b366e4fd4471087c148f93e0389
  main7 :: [GHC.Types.Char]
  {- Unfolding: (case GHC.Show.$wshowSignedInt
                        0
                        3
                        (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                   ConnectN.main8 }) -}
7c03e7723f8583aebc7f97494a438a3a
  main8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   " on a "#
                   ConnectN.main9) -}
3f7a1df9d17cd3f83124efc352b4cb78
  main9 :: [GHC.Types.Char]
  {- Unfolding: (case GHC.Show.$wshowSignedInt
                        0
                        3
                        (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                   ConnectN.main10 }) -}
e5ae4120d713b0cef9e7eb03940e8c2e
  main_a4 ::
    [[ConnectN.Move]]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [[ConnectN.Move]] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
c58d256d33614496af4f496e6e6704c5
  main_n :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "s : "#
                   ConnectN.main4) -}
22b1e58880404900d6a1ff125e7b6506
  main_optimalMoves :: [ConnectN.Move]
  {- Unfolding: (case ConnectN.$wgo 1 of ww { (#,#) ww1 ww2 ->
                 case ConnectN.main_a4
                        (GHC.Types.: @ [ConnectN.Move] ww1 ww2)
                        GHC.Prim.realWorld# of ds { (#,#) ipv ipv1 ->
                 GameLogic.argsup @ [ConnectN.Move] ipv1 ConnectN.p } }) -}
1e15425203c2769343a528e230e463a8
  movesToBoard :: [ConnectN.Move] -> ConnectN.Board
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ moves :: [ConnectN.Move] ->
                 ConnectN.movesToBoard_go
                   ConnectN.movesToBoard_players
                   moves
                   (GHC.Types.[] @ ConnectN.Position)) -}
c6bcb8683ecf8c1d9d3a778a858145a2
  movesToBoard1 :: [ConnectN.Player]
  {- HasNoCafRefs, Strictness: m2 -}
698f274c075d1fc17382bf2b5c8c57d5
  movesToBoard_go ::
    [ConnectN.Player]
    -> [GHC.Types.Int] -> ConnectN.Board -> ConnectN.Board
  {- Arity: 3, Strictness: <S,1*U><L,1*U><S,U> -}
b2afa1c1fd5334cbfd7eecafb62f2b89
  movesToBoard_players :: [ConnectN.Player]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ConnectN.Player
                   ConnectN.X
                   ConnectN.movesToBoard1) -}
b42d8ed2a9cd01a0fca902a43e513de4
  optimalOutcome :: ConnectN.R
  {- Unfolding: (case ConnectN.$wvalue
                        ConnectN.optimalOutcome1 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
ec5df55d206d78077ca420445c69e5da
  optimalOutcome1 :: ConnectN.Board
  {- Unfolding: (ConnectN.movesToBoard_go
                   ConnectN.movesToBoard_players
                   ConnectN.optimalPlay
                   (GHC.Types.[] @ ConnectN.Position)) -}
059bb0034b1bf96d35a27a940c9fe6b2
  optimalPlay :: [ConnectN.Move]
  {- Unfolding: (ConnectN.optimalPlay1 ConnectN.p) -}
ac408a4d064a7f064cd5fd69848c5993
  optimalPlay1 :: GameLogic.J ConnectN.R [ConnectN.Move]
  {- Unfolding: (GameLogic.bigotimes
                   @ ConnectN.Move
                   @ ConnectN.R
                   ConnectN.epsilons) -}
0dc3fccd2e813d553ed13a0ef193e7b9
  p :: [ConnectN.Move] -> ConnectN.R
  {- Arity: 1, Strictness: <L,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ ms :: [ConnectN.Move] ->
                 ConnectN.value (ConnectN.movesToBoard ms)) -}
a0dd018017dee1bc31b8c9f3d796fd01
  pPar :: [ConnectN.Move] -> [ConnectN.Move] -> ConnectN.R
  {- Arity: 2, Strictness: <L,1*U><L,1*U>m,
     Unfolding: InlineRule (2, True, False)
                (\ preceding :: [ConnectN.Move] ms :: [ConnectN.Move] ->
                 ConnectN.value
                   (ConnectN.movesToBoard
                      (GHC.Base.augment
                         @ GHC.Types.Int
                         (\ @ b c :: GHC.Types.Int -> b -> b[OneShot] n1 :: b[OneShot] ->
                          GHC.Base.foldr @ GHC.Types.Int @ b c n1 preceding)
                         ms))) -}
48cd699199737d718430fc8b75f0b97b
  parEpsilons ::
    [ConnectN.Move]
    -> [[ConnectN.Move] -> GameLogic.J ConnectN.R ConnectN.Move]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ preceding :: [ConnectN.Move] ->
                 case GHC.List.$wlenAcc
                        @ GHC.Types.Int
                        preceding
                        0 of ww2 { DEFAULT ->
                 let {
                   y :: GHC.Prim.Int# = GHC.Prim.-# 9 ww2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0 y) of wild {
                   GHC.Types.False
                   -> GHC.Types.[]
                        @ ([ConnectN.Move] -> GameLogic.J ConnectN.R ConnectN.Move)
                   GHC.Types.True
                   -> let {
                        poolOfMoves :: [GHC.Types.Int]
                        = Data.OldList.sortBy
                            @ GHC.Types.Int
                            GHC.Classes.compareInt
                            (Data.OldList.\\
                               @ GHC.Types.Int
                               GHC.Classes.$fEqInt
                               ConnectN.parEpsilons1
                               preceding)
                      } in
                      let {
                        epsilonO1 :: [GHC.Types.Int]
                                     -> GameLogic.J GHC.Types.Int GHC.Types.Int
                          {- Arity: 1, Strictness: <L,1*U> -}
                        = \ h :: [GHC.Types.Int] ->
                          let {
                            xs :: [GHC.Types.Int] = GameLogic.epsilons_go h poolOfMoves
                          } in
                          \ p1 :: GHC.Types.Int -> GHC.Types.Int ->
                          GameLogic.argsup
                            @ GHC.Types.Int
                            xs
                            (\ x1 :: GHC.Types.Int ->
                             case p1 x1 of wild1 { GHC.Types.I# x2 ->
                             GHC.Types.I# (GHC.Prim.negateInt# x2) })
                      } in
                      let {
                        epsilonX :: [GHC.Types.Int]
                                    -> GameLogic.J GHC.Types.Int GHC.Types.Int
                          {- Arity: 1, Strictness: <L,1*U>,
                             Unfolding: InlineRule (1, True, False)
                                        (\ h :: [GHC.Types.Int] ->
                                         GameLogic.argsup
                                           @ GHC.Types.Int
                                           (GameLogic.epsilons_go h poolOfMoves)) -}
                        = \ h :: [GHC.Types.Int] ->
                          GameLogic.argsup
                            @ GHC.Types.Int
                            (GameLogic.epsilons_go h poolOfMoves)
                      } in
                      letrec {
                        all :: [[GHC.Types.Int] -> GameLogic.J GHC.Types.Int GHC.Types.Int]
                        = GHC.Types.:
                            @ ([GHC.Types.Int] -> GameLogic.J GHC.Types.Int GHC.Types.Int)
                            epsilonX
                            a1
                        a1 :: [[GHC.Types.Int] -> GameLogic.J GHC.Types.Int GHC.Types.Int]
                        = GHC.Types.:
                            @ ([GHC.Types.Int] -> GameLogic.J GHC.Types.Int GHC.Types.Int)
                            epsilonO1
                            all
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww2 0) of wild1 {
                        GHC.Types.False
                        -> GHC.List.$wunsafeTake
                             @ ([ConnectN.Move] -> GameLogic.J ConnectN.R ConnectN.Move)
                             y
                             (ConnectN.$wunsafeDrop
                                @ ([GHC.Types.Int] -> GameLogic.J GHC.Types.Int GHC.Types.Int)
                                ww2
                                all)
                        GHC.Types.True
                        -> GHC.List.$wunsafeTake
                             @ ([ConnectN.Move] -> GameLogic.J ConnectN.R ConnectN.Move)
                             y
                             all } } }) -}
8044ccce459cf88f6b5715d96baf657e
  parEpsilons1 :: [GHC.Types.Int]
  {- Unfolding: (ConnectN.$wxs1 3) -}
ddfab5085c0497e8d5c828684e2b215b
  parOptimalPlay :: [ConnectN.Move] -> [ConnectN.Move]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ moves :: [ConnectN.Move] ->
                 GHC.Base.++
                   @ GHC.Types.Int
                   moves
                   (GameLogic.bigotimes
                      @ ConnectN.Move
                      @ ConnectN.R
                      (ConnectN.parEpsilons moves)
                      (ConnectN.pPar moves))) -}
d294451fbdcff960f25b3d378d7b80d4
  prettyPrint :: ConnectN.Board -> GHC.Base.String
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ b :: ConnectN.Board ->
                 letrec {
                   go4 :: [GHC.Types.Int]
                          -> [[(ConnectN.Coordinate,
                                ConnectN.Coordinate,
                                GHC.Base.Maybe ConnectN.Player)]]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [GHC.Types.Int] ->
                     case ds of wild {
                       []
                       -> GHC.Types.[]
                            @ [(ConnectN.Coordinate,
                                ConnectN.Coordinate,
                                GHC.Base.Maybe ConnectN.Player)]
                       : y ys
                       -> GHC.Types.:
                            @ [(ConnectN.Coordinate,
                                ConnectN.Coordinate,
                                GHC.Base.Maybe ConnectN.Player)]
                            (letrec {
                               go5 :: [(ConnectN.Coordinate, GHC.Types.Int, ConnectN.Player)]
                                      -> [(ConnectN.Coordinate,
                                           GHC.Types.Int,
                                           GHC.Base.Maybe ConnectN.Player)]
                                 {- Arity: 1, Strictness: <S,1*U> -}
                               = \ ds1 :: [(ConnectN.Coordinate,
                                            GHC.Types.Int,
                                            ConnectN.Player)] ->
                                 case ds1 of wild1 {
                                   []
                                   -> GHC.Types.[]
                                        @ (ConnectN.Coordinate,
                                           GHC.Types.Int,
                                           GHC.Base.Maybe ConnectN.Player)
                                   : y1 ys1
                                   -> case y1 of wild2 { (,,) ds2 y' ds3 ->
                                      case y' of wild3 { GHC.Types.I# x1 ->
                                      case y of wild4 { GHC.Types.I# y2 ->
                                      case GHC.Prim.tagToEnum#
                                             @ GHC.Types.Bool
                                             (GHC.Prim.==# x1 y2) of wild5 {
                                        GHC.Types.False -> go5 ys1
                                        GHC.Types.True
                                        -> GHC.Types.:
                                             @ (ConnectN.Coordinate,
                                                GHC.Types.Int,
                                                GHC.Base.Maybe ConnectN.Player)
                                             (ds2, wild3, GHC.Base.Just @ ConnectN.Player ds3)
                                             (go5 ys1) } } } } }
                             } in
                             Data.OldList.sortBy
                               @ (ConnectN.Coordinate,
                                  ConnectN.Coordinate,
                                  GHC.Base.Maybe ConnectN.Player)
                               ConnectN.prettyPrint_order
                               (Data.OldList.unionBy
                                  @ (ConnectN.Coordinate,
                                     ConnectN.Coordinate,
                                     GHC.Base.Maybe ConnectN.Player)
                                  ConnectN.prettyPrint_isBlank
                                  (go5 b)
                                  (GHC.List.zip3
                                     @ ConnectN.Coordinate
                                     @ ConnectN.Coordinate
                                     @ (GHC.Base.Maybe ConnectN.Player)
                                     ConnectN.prettyPrint7
                                     (GHC.List.repeat @ GHC.Types.Int y)
                                     ConnectN.prettyPrint_xs)))
                            (go4 ys) }
                 } in
                 case GHC.Base.map
                        @ [(ConnectN.Coordinate,
                            ConnectN.Coordinate,
                            GHC.Base.Maybe ConnectN.Player)]
                        @ [GHC.Types.Char]
                        ConnectN.prettyPrint3
                        (GHC.List.reverse1
                           @ [(ConnectN.Coordinate,
                               ConnectN.Coordinate,
                               GHC.Base.Maybe ConnectN.Player)]
                           (go4 ConnectN.prettyPrint7)
                           (GHC.Types.[]
                              @ [(ConnectN.Coordinate,
                                  ConnectN.Coordinate,
                                  GHC.Base.Maybe ConnectN.Player)])) of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : x1 xs1
                   -> Data.OldList.intercalate_$spoly_go
                        @ GHC.Types.Char
                        x1
                        (Data.OldList.prependToAll
                           @ [GHC.Types.Char]
                           ConnectN.prettyPrint1
                           xs1) }) -}
12aecf369a9f2da3f81997d03224fb63
  prettyPrint1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "\n"#
                   ConnectN.prettyPrint2) -}
c3091a4b1387507d242dd80359e33ad3
  prettyPrint2 :: [GHC.Types.Char]
  {- Unfolding: (ConnectN.$wxs2 3) -}
9240c20cc15c12d5088c9db4b047cc6f
  prettyPrint3 ::
    [(ConnectN.Coordinate,
      ConnectN.Coordinate,
      GHC.Base.Maybe ConnectN.Player)]
    -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ x1 :: [(ConnectN.Coordinate,
                           ConnectN.Coordinate,
                           GHC.Base.Maybe ConnectN.Player)] ->
                 GHC.CString.unpackAppendCString#
                   "  "#
                   (case GHC.Base.map
                           @ (ConnectN.Coordinate,
                              ConnectN.Coordinate,
                              GHC.Base.Maybe ConnectN.Player)
                           @ [GHC.Types.Char]
                           ConnectN.prettyPrint5
                           x1 of wild {
                      [] -> GHC.Types.[] @ GHC.Types.Char
                      : x2 xs1
                      -> Data.OldList.intercalate_$spoly_go
                           @ GHC.Types.Char
                           x2
                           (Data.OldList.prependToAll
                              @ [GHC.Types.Char]
                              ConnectN.prettyPrint4
                              xs1) })) -}
a40c81aa58938617c0fa6177ee9499b4
  prettyPrint4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " | "#) -}
ff1b2ef49d1b75327139966c63165ad7
  prettyPrint5 ::
    (ConnectN.Coordinate,
     ConnectN.Coordinate,
     GHC.Base.Maybe ConnectN.Player)
    -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: (ConnectN.Coordinate,
                          ConnectN.Coordinate,
                          GHC.Base.Maybe ConnectN.Player) ->
                 case ds of wild { (,,) ds1 ds2 p1 ->
                 case p1 of wild1 {
                   GHC.Base.Nothing -> ConnectN.prettyPrint6
                   GHC.Base.Just x1
                   -> case x1 of wild2 {
                        ConnectN.X -> ConnectN.$fReadPlayer11
                        ConnectN.O -> ConnectN.$fReadPlayer8 } } }) -}
15dc274c4784c8a6b12e724adc3f91d3
  prettyPrint6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " "#) -}
103517e793502b22bdcbce81d71b0c9b
  prettyPrint7 :: [GHC.Types.Int]
  {- Unfolding: (GHC.Enum.eftInt 1 3) -}
e5f2a4394aac5ef5a354f9e777699c65
  prettyPrint_isBlank ::
    (ConnectN.Coordinate,
     ConnectN.Coordinate,
     GHC.Base.Maybe ConnectN.Player)
    -> (ConnectN.Coordinate,
        ConnectN.Coordinate,
        GHC.Base.Maybe ConnectN.Player)
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U(U),1*U(U),A)><S(SLL),1*U(1*U(U),1*U(U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: (ConnectN.Coordinate,
                         ConnectN.Coordinate,
                         GHC.Base.Maybe ConnectN.Player)
                   w1 :: (ConnectN.Coordinate,
                          ConnectN.Coordinate,
                          GHC.Base.Maybe ConnectN.Player) ->
                 case w of ww { (,,) ww1 ww2 ww3 ->
                 case ww1 of ww4 { GHC.Types.I# ww5 ->
                 case w1 of ww6 { (,,) ww7 ww8 ww9 ->
                 case ww7 of ww10 { GHC.Types.I# ww11 ->
                 ConnectN.$wisBlank ww5 ww2 ww11 ww8 ww9 } } } }) -}
9ef6b343f2ba77a0801ec3b1c9e29159
  prettyPrint_order ::
    (ConnectN.Coordinate,
     ConnectN.Coordinate,
     GHC.Base.Maybe ConnectN.Player)
    -> (ConnectN.Coordinate,
        ConnectN.Coordinate,
        GHC.Base.Maybe ConnectN.Player)
    -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U(U),A,A)><S(SLL),1*U(1*U(U),A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: (ConnectN.Coordinate,
                          ConnectN.Coordinate,
                          GHC.Base.Maybe ConnectN.Player)
                   ds1 :: (ConnectN.Coordinate,
                           ConnectN.Coordinate,
                           GHC.Base.Maybe ConnectN.Player) ->
                 case ds of wild { (,,) x1 ds2 ds3 ->
                 case ds1 of wild1 { (,,) x' ds4 ds5 ->
                 GHC.Classes.compareInt x1 x' } }) -}
2fb0a1783dc1a2d27ea06ef772926ea4
  prettyPrint_xs :: [GHC.Base.Maybe ConnectN.Player]
  {- HasNoCafRefs, Strictness: m2 -}
22d007ce4fd535f93509a0d86fd15f93
  takeTurn ::
    ConnectN.Player
    -> ConnectN.Move -> ConnectN.Board -> ConnectN.Board
  {- Arity: 3, Strictness: <L,U><L,U(U)><S,U>,
     Unfolding: (\ p1 :: ConnectN.Player
                   m :: ConnectN.Move
                   b :: ConnectN.Board ->
                 letrec {
                   $wgo1 :: [(ConnectN.Move, ConnectN.Coordinate, ConnectN.Player)]
                            -> GHC.Prim.Int# -> GHC.Prim.Int#
                     {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                   = \ w :: [(ConnectN.Move, ConnectN.Coordinate, ConnectN.Player)]
                       ww :: GHC.Prim.Int# ->
                     case w of wild {
                       [] -> ww
                       : y ys
                       -> case y of wild1 { (,,) x1 ds ds1 ->
                          case x1 of wild2 { GHC.Types.I# x2 ->
                          case m of wild3 { GHC.Types.I# y1 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.==# x2 y1) of wild4 {
                            GHC.Types.False -> $wgo1 ys ww
                            GHC.Types.True -> $wgo1 ys (GHC.Prim.+# ww 1) } } } } }
                 } in
                 case $wgo1 b 0 of ww { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww 3) of wild {
                   GHC.Types.False -> ConnectN.takeTurn1 m b
                   GHC.Types.True
                   -> GHC.Base.++
                        @ (ConnectN.Coordinate, ConnectN.Coordinate, ConnectN.Player)
                        b
                        (GHC.Types.:
                           @ (ConnectN.Coordinate, ConnectN.Coordinate, ConnectN.Player)
                           (m, GHC.Types.I# (GHC.Prim.+# ww 1), p1)
                           (GHC.Types.[]
                              @ (ConnectN.Coordinate,
                                 ConnectN.Coordinate,
                                 ConnectN.Player))) } }) -}
2440a3e8a1fcfc5089be6e1b86cb7a5c
  takeTurn1 :: ConnectN.Move -> ConnectN.Board -> ConnectN.Board
  {- Arity: 2, Strictness: <L,U><L,U>b -}
2a1ac7046df78ed185ed24b41222e6c4
  value :: ConnectN.Board -> ConnectN.R
  {- Arity: 1, Strictness: <L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: ConnectN.Board ->
                 case ConnectN.$wvalue w of ww { DEFAULT -> GHC.Types.I# ww }) -}
477c631081f1b434ffcee83cb084e657
  width :: GHC.Types.Int
  {- Strictness: m, Unfolding: (ConnectN.winningAmount) -}
d2e42bc3d8c77b12cbd22e22eb9a94e4
  winningAmount :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 3) -}
ce2ba93d33b8da6f2f67e47c1a4bf4a0
  wins :: ConnectN.Player -> ConnectN.Board -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><L,U> -}
instance GHC.Classes.Eq [ConnectN.Player] = ConnectN.$fEqPlayer
instance GHC.Classes.Ord [ConnectN.Player] = ConnectN.$fOrdPlayer
instance GHC.Read.Read [ConnectN.Player] = ConnectN.$fReadPlayer
instance GHC.Show.Show [ConnectN.Player] = ConnectN.$fShowPlayer
"SPEC/ConnectN $dmreadsPrec @ Player" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                  ConnectN.Player
  GHC.Read.$dmreadsPrec @ ConnectN.Player $dRead
  = ConnectN.$fReadPlayer_$s$dmreadsPrec
"SPEC/ConnectN readListDefault @ Player" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                     ConnectN.Player
  GHC.Read.readListDefault @ ConnectN.Player $dRead
  = ConnectN.$fReadPlayer_$sreadListDefault
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

