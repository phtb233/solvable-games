
==================== FINAL INTERFACE ====================
2016-08-25 18:23:37.190511 UTC

interface main@main:Logic.GameLogic 7103
  interface hash: ea8788748e08cc2fbc16058276eaa980
  ABI hash: 26d44f799309be9333aa831cc195f912
  export-list hash: 02a96d8251ab1656b811a49d270bd213
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: dc2edb525f06ee6f0446ce66902b708e
  sig of: Nothing
  used TH splices: False
  where
exports:
  Logic.GameLogic.arginf
  Logic.GameLogic.argsup
  Logic.GameLogic.bigotimes
  Logic.GameLogic.contained
  Logic.GameLogic.delete
  Logic.GameLogic.epsilons
  Logic.GameLogic.find
  Logic.GameLogic.insert
  Logic.GameLogic.optimalStrategy
  Logic.GameLogic.otimes
  Logic.GameLogic.overline
  Logic.GameLogic.p
  Logic.GameLogic.setMinus
  Logic.GameLogic.someContained
  Logic.GameLogic.J
  Logic.GameLogic.K
  Logic.GameLogic.Move
  Logic.GameLogic.R
module dependencies:
package dependencies: base-4.8.2.0 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Debug.Trace 6660afb6094d69397ea084364da8f950
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
486de0d19655fd48bb48b5b1ae30d46e
  $wotimes ::
    Logic.GameLogic.J r x
    -> (x -> Logic.GameLogic.J r [x]) -> ([x] -> r) -> (# x, [x] #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,C(C1(U))><L,C(U)>, Inline: [0],
     Unfolding: (\ @ r
                   @ x
                   w :: Logic.GameLogic.J r x
                   w1 :: x -> Logic.GameLogic.J r [x]
                   w2 :: [x] -> r ->
                 let {
                   a0 :: x
                   = w (\ x0 :: x ->
                        w2
                          (GHC.Types.:
                             @ x
                             x0
                             (w1 x0 (\ x1 :: [x] -> w2 (GHC.Types.: @ x x0 x1)))))
                 } in
                 (# a0, w1 a0 (\ x1 :: [x] -> w2 (GHC.Types.: @ x a0 x1)) #)) -}
39dc6ad6d39dac8c71c92efcc89b4f9e
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
e62c617d76644dc2a111453607a27a3f
  type J r x = (x -> r) -> x
c5c17af0804b8deb7def3a1358309f87
  type K r x = (x -> r) -> r
c7e2eca8e5463609a01d6aa9c683673e
  type Move = GHC.Types.Int
4e1df7e7eefaeb9cc79bb87ae30892fe
  type R = GHC.Types.Int
96ecd49dd950b5b804860583045f1907
  arginf :: [x] -> Logic.GameLogic.J GHC.Types.Int x
  {- Arity: 2, Strictness: <S,1*U><L,C(U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ x xs :: [x] p1 :: x -> GHC.Types.Int ->
                 Logic.GameLogic.argsup
                   @ x
                   xs
                   (\ x1 :: x ->
                    case p1 x1 of wild { GHC.Types.I# x2 ->
                    GHC.Types.I# (GHC.Prim.negateInt# x2) })) -}
51152ae523909382c51faca10fd8c2ff
  argsup :: [x] -> Logic.GameLogic.J GHC.Types.Int x
  {- Arity: 2, Strictness: <S,1*U><L,C(U(1*U))>,
     Unfolding: (\ @ x ds :: [x] p1 :: x -> GHC.Types.Int ->
                 case ds of wild {
                   [] -> Logic.GameLogic.argsup2 @ x
                   : x1 xs
                   -> case p1 x1 of ww { GHC.Types.I# ww1 ->
                      letrec {
                        $wf :: [x] -> x -> GHC.Prim.Int# -> x
                          {- Arity: 3, Strictness: <L,1*U><L,U><S,1*U>, Inline: [0] -}
                        = \ w :: [x] w1 :: x ww2 :: GHC.Prim.Int# ->
                          case ww2 of ds1 {
                            DEFAULT
                            -> case w of wild1 {
                                 [] -> w1
                                 : x2 xs1
                                 -> case ds1 of ds2 {
                                      DEFAULT -> Logic.GameLogic.argsup1 @ x
                                      (-1)
                                      -> case p1 x2 of ww3 { GHC.Types.I# ww4 -> $wf xs1 x2 ww4 }
                                      0
                                      -> letrec {
                                           g :: [x] -> x {- Arity: 1, Strictness: <S,1*U> -}
                                           = \ ds3 :: [x] ->
                                             case ds3 of wild2 {
                                               [] -> w1
                                               : x3 xs2
                                               -> case p1 x3 of wild3 { GHC.Types.I# x4 ->
                                                  case x4 of wild4 { DEFAULT -> g xs2 1 -> x3 } } }
                                         } in
                                         g wild1 } }
                            1 -> w1 }
                      } in
                      $wf xs x1 ww1 } }) -}
6aaa17de37fb03572b1c8563c6c0124a
  argsup1 :: x
  {- Strictness: b -}
4e4355c0aa9af194ea58c0f81d1fc49b
  argsup2 :: x
  {- Unfolding: (\ @ x ->
                 Debug.Trace.trace
                   @ x
                   Logic.GameLogic.argsup3
                   (GHC.Err.undefined @ x)) -}
c0faadaedf79fa9bea572771b4c14597
  argsup3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "Error: an empty list was passed to argsup"#) -}
344a9cb8123787eadef3d179968b7b85
  bigotimes ::
    [[x] -> Logic.GameLogic.J r x] -> Logic.GameLogic.J r [x]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
8f08fdcddaf32fb746d5118f19e84814
  contained :: GHC.Classes.Ord x => [x] -> [x] -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),A,A,A,C(C1(U)),A,A,A)><S,1*U><L,1*U> -}
93deda60426c50abbb5b6fe12582a2f7
  delete :: GHC.Classes.Ord x => x -> [x] -> [x]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A)><L,U><S,1*U> -}
58f6919e33b7b260b88686b7f1ef04ab
  delete_$sdelete ::
    Logic.GameLogic.Move
    -> [Logic.GameLogic.Move] -> [Logic.GameLogic.Move]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U> -}
f210fa862d86af28c155e511c268e914
  epsilons ::
    [[Logic.GameLogic.Move]
     -> Logic.GameLogic.J Logic.GameLogic.R Logic.GameLogic.Move]
  {- Unfolding: (GHC.List.$wunsafeTake
                   @ ([Logic.GameLogic.Move]
                      -> Logic.GameLogic.J Logic.GameLogic.R Logic.GameLogic.Move)
                   9
                   Logic.GameLogic.epsilons_all) -}
ed1b4a566fb044924687c0bf9821e5a9
  epsilons1 ::
    [[Logic.GameLogic.Move]
     -> Logic.GameLogic.J GHC.Types.Int Logic.GameLogic.Move]
  {- Strictness: m2 -}
34b07a9b7b36fcee1ea4a8593afbc580
  epsilons2 ::
    [Logic.GameLogic.Move]
    -> Logic.GameLogic.J GHC.Types.Int Logic.GameLogic.Move
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ h :: [Logic.GameLogic.Move] ->
                 Logic.GameLogic.argsup
                   @ Logic.GameLogic.Move
                   (Logic.GameLogic.epsilons_$ssetMinus
                      Logic.GameLogic.epsilons3
                      h)) -}
38998b0925ed9be8759cb813c0febb87
  epsilons3 :: [GHC.Types.Int]
  {- Unfolding: (GHC.Enum.eftInt 0 8) -}
1be638153cdc2b1fa7eecd3badf3b9b0
  epsilons_$ssetMinus ::
    [Logic.GameLogic.Move]
    -> [Logic.GameLogic.Move] -> [Logic.GameLogic.Move]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ eta :: [Logic.GameLogic.Move]
                   eta1 :: [Logic.GameLogic.Move] ->
                 Logic.GameLogic.epsilons_go eta1 eta) -}
d4bae1c84ca7703d6d0a516547d7e976
  epsilons_all ::
    [[Logic.GameLogic.Move]
     -> Logic.GameLogic.J GHC.Types.Int Logic.GameLogic.Move]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ([Logic.GameLogic.Move]
                      -> Logic.GameLogic.J GHC.Types.Int Logic.GameLogic.Move)
                   Logic.GameLogic.epsilons2
                   Logic.GameLogic.epsilons1) -}
c95947ac8f11ce332c950188933c6ca6
  epsilons_go ::
    [Logic.GameLogic.Move]
    -> [Logic.GameLogic.Move] -> [Logic.GameLogic.Move]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
33d0a3fefbb5a1953b62f96514263af8
  find :: [x] -> Logic.GameLogic.J GHC.Types.Bool x
  {- Arity: 2, Strictness: <S,1*U><L,C(U)> -}
0cfdfdd3d2ff70032cf6b226600ea84b
  insert :: GHC.Classes.Ord x => x -> [x] -> [x]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A)><L,U><S,1*U> -}
6e5d1829b35844bd4ed89733d9377060
  optimalStrategy :: [Logic.GameLogic.Move] -> Logic.GameLogic.Move
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ as :: [Logic.GameLogic.Move] ->
                 case GHC.List.$wlenAcc @ GHC.Types.Int as 0 of ww2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww2 0) of wild1 {
                   GHC.Types.False
                   -> case Logic.GameLogic.bigotimes
                             @ Logic.GameLogic.Move
                             @ Logic.GameLogic.R
                             (Logic.GameLogic.$wunsafeDrop
                                @ ([Logic.GameLogic.Move]
                                   -> Logic.GameLogic.J Logic.GameLogic.R Logic.GameLogic.Move)
                                ww2
                                Logic.GameLogic.epsilons)
                             Logic.GameLogic.p of wild {
                        [] -> GHC.List.badHead @ Logic.GameLogic.Move : x ds1 -> x }
                   GHC.Types.True
                   -> case Logic.GameLogic.optimalStrategy1 of wild {
                        [] -> GHC.List.badHead @ Logic.GameLogic.Move
                        : x ds1 -> x } } }) -}
ccaa2e0edc308393b36c45a3eb5b11e7
  optimalStrategy1 :: [Logic.GameLogic.Move]
  {- Unfolding: (Logic.GameLogic.optimalStrategy2
                   Logic.GameLogic.p) -}
188ac5b6f9461d57afc7bdfa7a48b896
  optimalStrategy2 ::
    Logic.GameLogic.J Logic.GameLogic.R [Logic.GameLogic.Move]
  {- Unfolding: (Logic.GameLogic.bigotimes
                   @ Logic.GameLogic.Move
                   @ Logic.GameLogic.R
                   Logic.GameLogic.epsilons) -}
1b8e16759f094dbc5eedbe20cf8ff2a7
  otimes ::
    Logic.GameLogic.J r x
    -> (x -> Logic.GameLogic.J r [x]) -> Logic.GameLogic.J r [x]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,C(C1(U))><L,C(U)>m2, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ r
                   @ x
                   w :: Logic.GameLogic.J r x
                   w1 :: x -> Logic.GameLogic.J r [x]
                   w2 :: [x] -> r ->
                 case Logic.GameLogic.$wotimes
                        @ r
                        @ x
                        w
                        w1
                        w2 of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ x ww1 ww2 }) -}
306e8d059f27b73f7f20a9adeb7ded87
  overline :: Logic.GameLogic.J r x -> Logic.GameLogic.K r x
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><C(S),U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ r @ x e :: Logic.GameLogic.J r x p1 :: x -> r -> p1 (e p1)) -}
30c9a530ded937bf752b38c3061662f4
  p :: [Logic.GameLogic.Move] -> Logic.GameLogic.R
  {- Arity: 1, Strictness: <B,A>b,
     Unfolding: InlineRule (1, True, True)
                (\ ms :: [Logic.GameLogic.Move] ->
                 GHC.Err.undefined @ Logic.GameLogic.R) -}
9e687f4ea98fa5bb19d6b1054c1ce9b4
  setMinus :: GHC.Classes.Ord x => [x] -> [x] -> [x]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: (\ @ x
                   $dOrd :: GHC.Classes.Ord x
                   eta :: [x]
                   eta1 :: [x] ->
                 letrec {
                   go :: [x] -> [x] -> [x] {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ ds :: [x] eta2 :: [x] ->
                     case ds of wild {
                       [] -> eta2
                       : y ys -> go ys (Logic.GameLogic.delete @ x $dOrd y eta2) }
                 } in
                 go eta1 eta) -}
e04c4963b9555c72c15aa43b5daeb0f1
  someContained ::
    GHC.Classes.Ord x => [[x]] -> [x] -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),A,A,A,C(C1(U)),A,A,A)><S,1*U><L,1*U> -}
"SPEC delete @ Move" [ALWAYS] forall $dOrd :: GHC.Classes.Ord
                                                Logic.GameLogic.Move
  Logic.GameLogic.delete @ GHC.Types.Int $dOrd
  = Logic.GameLogic.delete_$sdelete
"SPEC setMinus @ Move" [ALWAYS] forall $dOrd :: GHC.Classes.Ord
                                                  Logic.GameLogic.Move
  Logic.GameLogic.setMinus @ GHC.Types.Int $dOrd
  = Logic.GameLogic.epsilons_$ssetMinus
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

