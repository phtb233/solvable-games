
==================== FINAL INTERFACE ====================
2016-09-03 15:50:23.808594 UTC

interface main@main:ConnectN 7103
  interface hash: 0cf59ff712b7f133a59610bacbc69a83
  ABI hash: 43e1b752bea14b835a063198e7ad44b7
  export-list hash: 08de2402677dbcd8948970f0b72e10ae
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 00e643ad7ce35edfdec2c9358b896e07
  sig of: Nothing
  used TH splices: False
  where
exports:
  ConnectN.argmax
  ConnectN.argmin
  ConnectN.epsilons
  ConnectN.epsilons'
  ConnectN.height
  ConnectN.main
  ConnectN.movesToBoard
  ConnectN.optimalOutcome
  ConnectN.optimalPlay
  ConnectN.p
  ConnectN.pPar
  ConnectN.parEpsilons
  ConnectN.parOptimalPlay
  ConnectN.parShowOptimalPlay
  ConnectN.prettyPrint
  ConnectN.showOptimalPlay
  ConnectN.takeTurn
  ConnectN.value
  ConnectN.width
  ConnectN.winningAmount
  ConnectN.wins
  ConnectN.Board
  ConnectN.Move
  ConnectN.Player{ConnectN.O ConnectN.X}
  ConnectN.Position
  ConnectN.R
  ConnectN.X
  ConnectN.Y
module dependencies: Logic.GameLogic
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0 containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 parallel-3.2.1.0@paral_BEbrIfHgHtmEpYU5TfKWK9
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Control.Exception e9090e246fba030faecf7b81b3e8e320
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Enum debc6de3086023a15993ab0cecffb90b
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Read b423b4506a014855edbd329b567629f3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:System.IO 0248c1e850b7ea124cf7a2e1669ebf67
import  -/  deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59:Control.DeepSeq 269ef0c8d019d01c547937e1ae8fb2e8
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  Logic.GameLogic 26d44f799309be9333aa831cc195f912
  exports: 02a96d8251ab1656b811a49d270bd213
  J e62c617d76644dc2a111453607a27a3f
  arginf 96ecd49dd950b5b804860583045f1907
  argsup 51152ae523909382c51faca10fd8c2ff
  bigotimes 344a9cb8123787eadef3d179968b7b85
  contained 8f08fdcddaf32fb746d5118f19e84814
  setMinus 9e687f4ea98fa5bb19d6b1054c1ce9b4
import  -/  parallel-3.2.1.0@paral_BEbrIfHgHtmEpYU5TfKWK9:Control.Parallel 1b43eb56445614e8fc63261d7d1b82ab
import  -/  parallel-3.2.1.0@paral_BEbrIfHgHtmEpYU5TfKWK9:Control.Parallel.Strategies e559e49e970aa71559d76fa817ccb0ac
ab973452333c92539131f2a6838980fc
  $fEqPlayer :: GHC.Classes.Eq ConnectN.Player
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ConnectN.Player
                  ConnectN.$fEqPlayer_$c==
                  ConnectN.$fEqPlayer_$c/= -}
ab973452333c92539131f2a6838980fc
  $fEqPlayer_$c/= ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: ConnectN.Player b :: ConnectN.Player ->
                 case a1 of wild {
                   ConnectN.X
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.False ConnectN.O -> GHC.Types.True }
                   ConnectN.O
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.True ConnectN.O -> GHC.Types.False } }) -}
ab973452333c92539131f2a6838980fc
  $fEqPlayer_$c== ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: ConnectN.Player ds1 :: ConnectN.Player ->
                 case ds of wild {
                   ConnectN.X
                   -> case ds1 of wild1 {
                        ConnectN.X -> GHC.Types.True ConnectN.O -> GHC.Types.False }
                   ConnectN.O
                   -> case ds1 of wild1 {
                        ConnectN.X -> GHC.Types.False ConnectN.O -> GHC.Types.True } }) -}
ab973452333c92539131f2a6838980fc
  $fOrdPlayer :: GHC.Classes.Ord ConnectN.Player
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ConnectN.Player
                  ConnectN.$fEqPlayer
                  ConnectN.$fOrdPlayer_$ccompare
                  ConnectN.$fOrdPlayer_$c<
                  ConnectN.$fOrdPlayer_$c<=
                  ConnectN.$fOrdPlayer_$c>
                  ConnectN.$fOrdPlayer_$c>=
                  ConnectN.$fOrdPlayer_$cmax
                  ConnectN.$fOrdPlayer_$cmin -}
ab973452333c92539131f2a6838980fc
  $fOrdPlayer_$c< ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: ConnectN.Player b :: ConnectN.Player ->
                 case a1 of wild {
                   ConnectN.X
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.False ConnectN.O -> GHC.Types.True }
                   ConnectN.O -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
ab973452333c92539131f2a6838980fc
  $fOrdPlayer_$c<= ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: ConnectN.Player b :: ConnectN.Player ->
                 case a1 of wild {
                   ConnectN.X -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   ConnectN.O
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.False ConnectN.O -> GHC.Types.True } }) -}
ab973452333c92539131f2a6838980fc
  $fOrdPlayer_$c> ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: ConnectN.Player b :: ConnectN.Player ->
                 case a1 of wild {
                   ConnectN.X -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   ConnectN.O
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.True ConnectN.O -> GHC.Types.False } }) -}
ab973452333c92539131f2a6838980fc
  $fOrdPlayer_$c>= ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: ConnectN.Player b :: ConnectN.Player ->
                 case a1 of wild {
                   ConnectN.X
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.True ConnectN.O -> GHC.Types.False }
                   ConnectN.O -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
ab973452333c92539131f2a6838980fc
  $fOrdPlayer_$ccompare ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: ConnectN.Player b :: ConnectN.Player ->
                 case a1 of wild {
                   ConnectN.X
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.EQ ConnectN.O -> GHC.Types.LT }
                   ConnectN.O
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.GT ConnectN.O -> GHC.Types.EQ } }) -}
ab973452333c92539131f2a6838980fc
  $fOrdPlayer_$cmax ::
    ConnectN.Player -> ConnectN.Player -> ConnectN.Player
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x1 :: ConnectN.Player y :: ConnectN.Player ->
                 case x1 of wild {
                   ConnectN.X -> y
                   ConnectN.O -> case y of wild1 { DEFAULT -> ConnectN.O } }) -}
ab973452333c92539131f2a6838980fc
  $fOrdPlayer_$cmin ::
    ConnectN.Player -> ConnectN.Player -> ConnectN.Player
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x1 :: ConnectN.Player y :: ConnectN.Player ->
                 case x1 of wild {
                   ConnectN.X -> case y of wild1 { DEFAULT -> ConnectN.X }
                   ConnectN.O -> y }) -}
ab973452333c92539131f2a6838980fc
  $fReadPlayer :: GHC.Read.Read ConnectN.Player
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ConnectN.Player
                  ConnectN.$fReadPlayer_$s$dmreadsPrec
                  ConnectN.$fReadPlayer_$sreadListDefault
                  ConnectN.$fReadPlayer_$creadPrec
                  ConnectN.$fReadPlayer_$creadListPrec -}
ab973452333c92539131f2a6838980fc
  $fReadPlayer1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([ConnectN.Player] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [ConnectN.Player] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ ConnectN.Player
                   ConnectN.$fReadPlayer2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <ConnectN.Player>_R))
                   @ b
                   eta1) -}
ab973452333c92539131f2a6838980fc
  $fReadPlayer10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (ConnectN.Player -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: ConnectN.Player -> Text.ParserCombinators.ReadP.P b ->
                 eta ConnectN.X) -}
df157d8d09343247225c2c79cc7b4615
  $fReadPlayer11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "X"#) -}
ab973452333c92539131f2a6838980fc
  $fReadPlayer2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP ConnectN.Player
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ ConnectN.Player
                   ConnectN.$fReadPlayer3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <ConnectN.Player>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <ConnectN.Player>_R)))) -}
ab973452333c92539131f2a6838980fc
  $fReadPlayer3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (ConnectN.Player -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: ConnectN.Player -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ ConnectN.Player
                   ConnectN.$fReadPlayer4
                   eta
                   @ b
                   eta1) -}
ab973452333c92539131f2a6838980fc
  $fReadPlayer4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player)
                   ConnectN.$fReadPlayer9
                   ConnectN.$fReadPlayer5) -}
ab973452333c92539131f2a6838980fc
  $fReadPlayer5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player)
                   ConnectN.$fReadPlayer6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player))) -}
ab973452333c92539131f2a6838980fc
  $fReadPlayer6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player)
  {- Strictness: m,
     Unfolding: ((ConnectN.$fReadPlayer8,
                  ConnectN.$fReadPlayer7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <ConnectN.Player>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <ConnectN.Player>_R))))) -}
ab973452333c92539131f2a6838980fc
  $fReadPlayer7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (ConnectN.Player -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: ConnectN.Player -> Text.ParserCombinators.ReadP.P b ->
                 eta ConnectN.O) -}
6e6d975ae9f719bef576edaadaf3bac3
  $fReadPlayer8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "O"#) -}
ab973452333c92539131f2a6838980fc
  $fReadPlayer9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player)
  {- Strictness: m,
     Unfolding: ((ConnectN.$fReadPlayer11,
                  ConnectN.$fReadPlayer10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <ConnectN.Player>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <ConnectN.Player>_R))))) -}
ab973452333c92539131f2a6838980fc
  $fReadPlayer_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [ConnectN.Player]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                ConnectN.$fReadPlayer1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[ConnectN.Player]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[ConnectN.Player]>_R))) -}
ab973452333c92539131f2a6838980fc
  $fReadPlayer_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                ConnectN.$fReadPlayer2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <ConnectN.Player>_R)) -}
ab973452333c92539131f2a6838980fc
  $fReadPlayer_$s$dmreadsPrec ::
    GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS ConnectN.Player
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ ConnectN.Player
                   ConnectN.$fReadPlayer_$creadPrec
                   eta) -}
ab973452333c92539131f2a6838980fc
  $fReadPlayer_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [ConnectN.Player]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [ConnectN.Player]
                   ((ConnectN.$fReadPlayer_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[ConnectN.Player]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <[ConnectN.Player]>_R)
                      @ [ConnectN.Player]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [ConnectN.Player]))) -}
ab973452333c92539131f2a6838980fc
  $fShowPlayer :: GHC.Show.Show ConnectN.Player
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ConnectN.Player
                  ConnectN.$fShowPlayer_$cshowsPrec
                  ConnectN.$fShowPlayer_$cshow
                  ConnectN.$fShowPlayer_$cshowList -}
ab973452333c92539131f2a6838980fc
  $fShowPlayer1 :: ConnectN.Player -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: ConnectN.Player eta :: GHC.Base.String ->
                 case ds of wild {
                   ConnectN.X
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n ConnectN.$fReadPlayer11)
                        eta
                   ConnectN.O
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n ConnectN.$fReadPlayer8)
                        eta }) -}
ab973452333c92539131f2a6838980fc
  $fShowPlayer_$cshow :: ConnectN.Player -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x1 :: ConnectN.Player ->
                 case x1 of wild {
                   ConnectN.X -> ConnectN.$fReadPlayer11
                   ConnectN.O -> ConnectN.$fReadPlayer8 }) -}
ab973452333c92539131f2a6838980fc
  $fShowPlayer_$cshowList :: [ConnectN.Player] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ ConnectN.Player
                   ConnectN.$fShowPlayer1) -}
ab973452333c92539131f2a6838980fc
  $fShowPlayer_$cshowsPrec ::
    GHC.Types.Int -> ConnectN.Player -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: ConnectN.Player
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   ConnectN.X
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n ConnectN.$fReadPlayer11)
                        eta
                   ConnectN.O
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n ConnectN.$fReadPlayer8)
                        eta }) -}
8ab2f7189bfdfd0edf502c77ff262072
  $wgo :: GHC.Prim.Int# -> (# [ConnectN.Move], [[ConnectN.Move]] #)
  {- Arity: 1, Strictness: <L,U>, Inline: [0] -}
0a22e1f976f2e79ec718bab2a120dfd6
  $wisBlank ::
    GHC.Prim.Int#
    -> ConnectN.Y
    -> GHC.Prim.Int#
    -> ConnectN.Y
    -> GHC.Base.Maybe ConnectN.Player
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: ConnectN.Y
                   ww2 :: GHC.Prim.Int#
                   ww3 :: ConnectN.Y
                   ww4 :: GHC.Base.Maybe ConnectN.Player ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Types.I# x1 ->
                      case ww3 of wild2 { GHC.Types.I# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x1 y) of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> Data.Maybe.isNothing @ ConnectN.Player ww4 } } } }) -}
addbb15bd850c9389bc219ff1d9b5d76
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
19115b0a8322365729cff44a6cabd5a0
  $wvalue :: ConnectN.Board -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ w :: ConnectN.Board ->
                 case ConnectN.wins ConnectN.X w of wild {
                   GHC.Types.False
                   -> case ConnectN.wins ConnectN.O w of wild1 {
                        GHC.Types.False -> 0 GHC.Types.True -> (-1) }
                   GHC.Types.True -> 1 }) -}
d8557d99d23f9bf5761f18f0531b5fb7
  $wxs :: GHC.Prim.Int# -> [GHC.Types.Int]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
2cfa72c50dd009bcaaa9dc9beb8b2632
  $wxs1 :: GHC.Prim.Int# -> [GHC.Types.Int]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
f2e6c97c65c59ae733bbacc46a96ba6f
  $wxs2 :: GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
7924e8e8172a6d50bcf8fa501117083c
  $wxs3 :: GHC.Prim.Int# -> [GHC.Types.Int]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
4b9e104760e0d1b1157ef29a044bd431
  type Board = [ConnectN.Position]
f6732f5e1ddc64e1de69ae471e9e69e2
  type Move = GHC.Types.Int
ab973452333c92539131f2a6838980fc
  data Player = X | O
    Promotable
4f98d2d50de1a166e44e916be66bf114
  type Position = (ConnectN.X, ConnectN.Y, ConnectN.Player)
35e85e55bd7532d12206eff38fd7f9f6
  type R = GHC.Types.Int
1a3d51d5bc0c9c08957c003393c0a5d3
  type X = GHC.Types.Int
97c037883fb87ba9d346c5cab1838b08
  type Y = GHC.Types.Int
4ed4d303dfa985dbd9a3e65c3794e1a8
  argmax ::
    (Control.DeepSeq.NFData a, GHC.Classes.Ord a) =>
    [a] -> (a -> GHC.Types.Int) -> [a]
  {- Arity: 4,
     Strictness: <L,C(U)><L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><L,C(U)>,
     Unfolding: (\ @ a1
                   $dNFData :: Control.DeepSeq.NFData a1
                   $dOrd :: GHC.Classes.Ord a1
                   eta :: [a1]
                   eta1 :: a1 -> GHC.Types.Int ->
                 case eta of wild {
                   [] -> ConnectN.argmax5 @ a1
                   : ipv ipv1
                   -> let {
                        graph :: [(GHC.Types.Int, a1)]
                        = Data.OldList.sortBy
                            @ (GHC.Types.Int, a1)
                            (\ w3 :: (GHC.Types.Int, a1) w4 :: (GHC.Types.Int, a1)[OneShot] ->
                             case w3 of ww { (,) ww1 ww2 ->
                             case w4 of ww3 { (,) ww4 ww5 ->
                             case ww1 of wild1 { GHC.Types.I# x# ->
                             case ww4 of wild2 { GHC.Types.I# y# ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.<# x# y#) of wild3 {
                               GHC.Types.False
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.==# x# y#) of wild4 {
                                    GHC.Types.False -> GHC.Types.GT
                                    GHC.Types.True -> GHC.Classes.compare @ a1 $dOrd ww2 ww5 }
                               GHC.Types.True -> GHC.Types.LT } } } } })
                            (Control.Parallel.Strategies.parMap
                               @ (GHC.Types.Int, a1)
                               @ a1
                               (\ x1 :: (GHC.Types.Int, a1)
                                  eta2 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                                case GHC.Prim.seq#
                                       @ ()
                                       @ GHC.Prim.RealWorld
                                       (case x1 of wild1 { (,) x2 y ->
                                        case x2 of ds1 { GHC.Types.I# ipv2 ->
                                        $dNFData `cast` (Control.DeepSeq.NTCo:NFData[0] <a1>_N)
                                          y } })
                                       eta2 of ds { (#,#) ipv2 ipv3 ->
                                (# ipv2, x1 #) })
                                 `cast`
                               (<(GHC.Types.Int, a1)>_R
                                ->_R Sym (Control.Parallel.Strategies.NTCo:Eval[0]
                                              <(GHC.Types.Int, a1)>_R))
                               (\ x1 :: a1 -> (eta1 x1, x1))
                               wild)
                      } in
                      let {
                        lvl16 :: GHC.Types.Int
                        = case ConnectN.argmax4
                                 @ a1
                                 graph
                                 (GHC.List.lastError @ (GHC.Types.Int, a1)) of wild1 { (,) x1 ds1 ->
                          x1 }
                      } in
                      letrec {
                        go3 :: [(GHC.Types.Int, a1)] -> [a1]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ ds :: [(GHC.Types.Int, a1)] ->
                          case ds of wild1 {
                            [] -> GHC.Types.[] @ a1
                            : y ys
                            -> case y of wild2 { (,) v x1 ->
                               case v of wild3 { GHC.Types.I# x2 ->
                               case lvl16 of wild4 { GHC.Types.I# y1 ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.==# x2 y1) of wild5 {
                                 GHC.Types.False -> go3 ys
                                 GHC.Types.True -> GHC.Types.: @ a1 x1 (go3 ys) } } } } }
                      } in
                      go3 graph }) -}
b9254784ce5f40623df113fa180b6afc
  argmax1 ::
    (GHC.Types.Int, GHC.Types.Int)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (GHC.Types.Int, GHC.Types.Int) #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x1 :: (GHC.Types.Int, GHC.Types.Int)
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.Prim.seq#
                        @ ()
                        @ GHC.Prim.RealWorld
                        (case x1 of wild { (,) x2 y ->
                         case x2 of ds1 { GHC.Types.I# ipv ->
                         case y of ds2 { GHC.Types.I# ipv1 -> GHC.Tuple.() } } })
                        eta of ds { (#,#) ipv ipv1 ->
                 (# ipv, x1 #) }) -}
6875304a6e2d9464c0a0a217b4726676
  argmax2 ::
    (GHC.Types.Int, GHC.Types.Int)
    -> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (\ w3 :: (GHC.Types.Int, GHC.Types.Int)
                   w4 :: (GHC.Types.Int, GHC.Types.Int)[OneShot] ->
                 case w3 of ww { (,) ww1 ww2 ->
                 case w4 of ww3 { (,) ww4 ww5 ->
                 case ww1 of wild { GHC.Types.I# x# ->
                 case ww4 of wild1 { GHC.Types.I# y# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# x# y#) of wild2 {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x# y#) of wild3 {
                        GHC.Types.False -> GHC.Types.GT
                        GHC.Types.True -> GHC.Classes.compareInt ww2 ww5 }
                   GHC.Types.True -> GHC.Types.LT } } } } }) -}
38cf678988443ef1ba922af48a4c9c32
  argmax3 :: [GHC.Types.Int]
  {- Strictness: b -}
f98b84052ef6b5dd38100c1fe8e997d3
  argmax4 ::
    [(GHC.Types.Int, a)] -> (GHC.Types.Int, a) -> (GHC.Types.Int, a)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U,U)> -}
99fd0fb0ab09f2611406e24fc080c33d
  argmax5 :: [a]
  {- Strictness: b -}
38b9794d53fba8276c6346957706c1e9
  argmax_$sargmax ::
    [GHC.Types.Int]
    -> (GHC.Types.Int -> GHC.Types.Int) -> [GHC.Types.Int]
  {- Arity: 2, Strictness: <S,1*U><L,C(U)>,
     Unfolding: (\ eta :: [GHC.Types.Int]
                   eta1 :: GHC.Types.Int -> GHC.Types.Int ->
                 case eta of wild {
                   [] -> ConnectN.argmax3
                   : ipv ipv1
                   -> let {
                        graph :: [(GHC.Types.Int, GHC.Types.Int)]
                        = Data.OldList.sortBy
                            @ (GHC.Types.Int, GHC.Types.Int)
                            ConnectN.argmax2
                            (Control.Parallel.Strategies.parMap
                               @ (GHC.Types.Int, GHC.Types.Int)
                               @ GHC.Types.Int
                               ConnectN.argmax1
                                 `cast`
                               (<(GHC.Types.Int, GHC.Types.Int)>_R
                                ->_R Sym (Control.Parallel.Strategies.NTCo:Eval[0]
                                              <(GHC.Types.Int, GHC.Types.Int)>_R))
                               (\ x1 :: GHC.Types.Int -> (eta1 x1, x1))
                               wild)
                      } in
                      let {
                        lvl16 :: GHC.Types.Int
                        = case ConnectN.argmax_go
                                 graph
                                 (GHC.List.lastError
                                    @ (GHC.Types.Int, GHC.Types.Int)) of wild1 { (,) x1 ds1 ->
                          x1 }
                      } in
                      letrec {
                        go3 :: [(GHC.Types.Int, GHC.Types.Int)] -> [GHC.Types.Int]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ ds :: [(GHC.Types.Int, GHC.Types.Int)] ->
                          case ds of wild1 {
                            [] -> GHC.Types.[] @ GHC.Types.Int
                            : y ys
                            -> case y of wild2 { (,) v x1 ->
                               case v of wild3 { GHC.Types.I# x2 ->
                               case lvl16 of wild4 { GHC.Types.I# y1 ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.==# x2 y1) of wild5 {
                                 GHC.Types.False -> go3 ys
                                 GHC.Types.True -> GHC.Types.: @ GHC.Types.Int x1 (go3 ys) } } } } }
                      } in
                      go3 graph }) -}
d157a6aa3e2561e930fa263a7302c23f
  argmax_go ::
    [(GHC.Types.Int, GHC.Types.Int)]
    -> (GHC.Types.Int, GHC.Types.Int) -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U,U)> -}
1d1f8a50c8fce5ce0565ef8f4836101b
  argmin ::
    (Control.DeepSeq.NFData a, GHC.Classes.Ord a) =>
    [a] -> (a -> GHC.Types.Int) -> [a]
  {- Arity: 4,
     Strictness: <L,C(U)><L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><L,C(U(U))>,
     Unfolding: (\ @ a1
                   $dNFData :: Control.DeepSeq.NFData a1
                   $dOrd :: GHC.Classes.Ord a1
                   ds :: [a1]
                   ds1 :: a1 -> GHC.Types.Int ->
                 case ds of wild {
                   [] -> ConnectN.argmin2 @ a1
                   : ipv ipv1
                   -> ConnectN.argmax
                        @ a1
                        $dNFData
                        $dOrd
                        wild
                        (\ x1 :: a1 ->
                         case ds1 x1 of wild1 { GHC.Types.I# x2 ->
                         GHC.Types.I# (GHC.Prim.negateInt# x2) }) }) -}
3033cb1072675a37e4399342d0e0daa8
  argmin1 :: [GHC.Types.Int]
  {- Strictness: b -}
d5349e99a01ad6f121f39b34fbbb978e
  argmin2 :: [a]
  {- Strictness: b -}
ad822f3cff222b779287f714cb3a81c6
  argmin_$sargmin ::
    [GHC.Types.Int]
    -> (GHC.Types.Int -> GHC.Types.Int) -> [GHC.Types.Int]
  {- Arity: 2, Strictness: <S,1*U><L,C(U(U))>,
     Unfolding: (\ ds :: [GHC.Types.Int]
                   ds1 :: GHC.Types.Int -> GHC.Types.Int ->
                 case ds of wild {
                   [] -> ConnectN.argmin1
                   : ipv ipv1
                   -> ConnectN.argmax_$sargmax
                        wild
                        (\ x1 :: GHC.Types.Int ->
                         case ds1 x1 of wild1 { GHC.Types.I# x2 ->
                         GHC.Types.I# (GHC.Prim.negateInt# x2) }) }) -}
991d0be44da36dcb0e4dabbb04f12f62
  epsilons ::
    [[ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move]
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ GHC.Types.Int
                        ConnectN.epsilons_poolOfMoves
                        0 of ww2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0 ww2) of wild {
                   GHC.Types.False
                   -> GHC.Types.[]
                        @ ([ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move)
                   GHC.Types.True
                   -> GHC.List.$wunsafeTake
                        @ ([ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move)
                        ww2
                        ConnectN.epsilons_all } }) -}
d606a58e164f7a6243a2c63f30f2cbd9
  epsilons' ::
    [[ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move]
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ GHC.Types.Int
                        ConnectN.epsilons'_poolOfMoves
                        0 of ww2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0 ww2) of wild {
                   GHC.Types.False
                   -> GHC.Types.[]
                        @ ([ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move)
                   GHC.Types.True
                   -> GHC.List.$wunsafeTake
                        @ ([ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move)
                        ww2
                        ConnectN.epsilons'1 } }) -}
467858a625fc8f1c80d7dd6bbc680f96
  epsilons'1 ::
    [[GHC.Types.Int]
     -> (GHC.Types.Int -> GHC.Types.Int) -> GHC.Types.Int]
  {- Unfolding: (GHC.Types.:
                   @ ([GHC.Types.Int]
                      -> (GHC.Types.Int -> GHC.Types.Int) -> GHC.Types.Int)
                   ConnectN.epsilons'6
                   ConnectN.epsilons'2) -}
a33be88c6670bf39185ce4c25ade7994
  epsilons'2 ::
    [[GHC.Types.Int]
     -> (GHC.Types.Int -> GHC.Types.Int) -> GHC.Types.Int]
  {- Unfolding: (GHC.Types.:
                   @ ([GHC.Types.Int]
                      -> (GHC.Types.Int -> GHC.Types.Int) -> GHC.Types.Int)
                   ConnectN.epsilons'5
                   ConnectN.epsilons'_all) -}
ce7d01ba99b5fe547ce399047bc88996
  epsilons'3 ::
    [[GHC.Types.Int] -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int]
  {- Strictness: m2 -}
3c5690116966a01f96db2287550d99f6
  epsilons'4 :: [GHC.Types.Int]
  {- Unfolding: (ConnectN.$wxs1 3) -}
766bea511d2f90e2074049fc6c7d1d0a
  epsilons'5 ::
    [GHC.Types.Int]
    -> (GHC.Types.Int -> GHC.Types.Int) -> GHC.Types.Int
  {- Arity: 1,
     Unfolding: (\ h :: [GHC.Types.Int] ->
                 let {
                   a1 :: [Logic.GameLogic.Move]
                   = Logic.GameLogic.epsilons_go h ConnectN.epsilons'_poolOfMoves
                 } in
                 \ x1 :: GHC.Types.Int -> GHC.Types.Int ->
                 case ConnectN.argmin_$sargmin a1 x1 of wild {
                   [] -> GHC.List.badHead @ GHC.Types.Int : x2 ds1 -> x2 }) -}
7f303a172e103e1ced9ab0da10c1606b
  epsilons'6 ::
    [GHC.Types.Int]
    -> (GHC.Types.Int -> GHC.Types.Int) -> GHC.Types.Int
  {- Arity: 1,
     Unfolding: (\ h :: [GHC.Types.Int] ->
                 let {
                   a1 :: [Logic.GameLogic.Move]
                   = Logic.GameLogic.epsilons_go h ConnectN.epsilons'_poolOfMoves
                 } in
                 \ x1 :: GHC.Types.Int -> GHC.Types.Int ->
                 case ConnectN.argmax_$sargmax a1 x1 of wild {
                   [] -> GHC.List.badHead @ GHC.Types.Int : x2 ds1 -> x2 }) -}
51b7090afe23cdcde108384f2c442517
  epsilons'_all ::
    [[GHC.Types.Int] -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ([GHC.Types.Int]
                      -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int)
                   ConnectN.epsilons'_epsilonX
                   ConnectN.epsilons'3) -}
2471075e5f693b7201535a75215907dc
  epsilons'_epsilonX ::
    [GHC.Types.Int] -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ h :: [GHC.Types.Int] ->
                 Logic.GameLogic.argsup
                   @ GHC.Types.Int
                   (Logic.GameLogic.epsilons_go h ConnectN.epsilons'_poolOfMoves)) -}
d56a8f40dfbe2d463676e9ef3c0359c6
  epsilons'_poolOfMoves :: [GHC.Types.Int]
  {- Unfolding: (Data.OldList.sortBy
                   @ GHC.Types.Int
                   GHC.Classes.compareInt
                   ConnectN.epsilons'4) -}
34a6aca2a4c314f957ce89e1a01d91e3
  epsilons1 ::
    [[GHC.Types.Int] -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int]
  {- Strictness: m2 -}
8e7e8312641cbbbeefc8da999363adec
  epsilons2 :: [GHC.Types.Int]
  {- Unfolding: (ConnectN.$wxs 3) -}
f9c7ca2b999545a85164832f1850d4de
  epsilons_all ::
    [[GHC.Types.Int] -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ([GHC.Types.Int]
                      -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int)
                   ConnectN.epsilons_epsilonX
                   ConnectN.epsilons1) -}
23ddbc0655fcbaf518b3b9274cfd4362
  epsilons_epsilonX ::
    [GHC.Types.Int] -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ h :: [GHC.Types.Int] ->
                 Logic.GameLogic.argsup
                   @ GHC.Types.Int
                   (Logic.GameLogic.epsilons_go h ConnectN.epsilons_poolOfMoves)) -}
d1403f167117484e481488b99614ed61
  epsilons_poolOfMoves :: [GHC.Types.Int]
  {- Unfolding: (Data.OldList.sortBy
                   @ GHC.Types.Int
                   GHC.Classes.compareInt
                   ConnectN.epsilons2) -}
ffd372863d63a31fddf3e05b08239c9e
  height :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 3) -}
6514b48c9eb625c83bf109a96fcb5236
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                ConnectN.main1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
be9cd5cec5e7f5e617f882e2744c0cda
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        ConnectN.main9
                        GHC.Types.True
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        ConnectN.main6
                        GHC.Types.True
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   ConnectN.main2
                   GHC.Types.True
                   ipv2 } }) -}
9a6afd98d66dc197e8dc7b49eecbc8e3
  main10 :: [GHC.Types.Char]
  {- Unfolding: (case GHC.Show.$wshowSignedInt
                        0
                        3
                        (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                   ConnectN.main11 }) -}
d468e18155b7ef2f147a949c6c2f8d86
  main11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   " on a "#
                   ConnectN.main12) -}
a8006a5505d430b0661668e3ff1c3176
  main12 :: [GHC.Types.Char]
  {- Unfolding: (case GHC.Show.$wshowSignedInt
                        0
                        3
                        (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                   ConnectN.main13 }) -}
e2e10199d75cb8e77ccd11448b191110
  main13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "x"#
                   ConnectN.main14) -}
7ead9af3f9b9385379353985847bc488
  main14 :: [GHC.Types.Char]
  {- Unfolding: (case GHC.Show.$wshowSignedInt
                        0
                        3
                        (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                   ConnectN.main15 }) -}
a5b360097e2d208d01e1aa34ffe29cdd
  main15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " grid;"#) -}
fdb2eb5073067272756660212e1d9097
  main2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "\n"#
                   ConnectN.main3) -}
66ea0e156ecced3a813b8236472a8911
  main3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   ConnectN.main4
                   ConnectN.main_n) -}
2a8c72108ea33e0e08554f847141002c
  main4 :: GHC.Base.String
  {- Unfolding: (ConnectN.prettyPrint ConnectN.main5) -}
3294cdd8500189695e6df025895d3743
  main5 :: ConnectN.Board
  {- Unfolding: (ConnectN.movesToBoard_go
                   ConnectN.movesToBoard_players
                   ConnectN.main_optimalMoves
                   (GHC.Types.[] @ ConnectN.Position)) -}
19c9489f9d307efe1b0787477e85fc82
  main6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "X "#
                   ConnectN.main7) -}
299ea182aeab1996cb6f00c026b4c996
  main7 :: [GHC.Types.Char]
  {- Unfolding: (case ConnectN.$wvalue ConnectN.main5 of ww {
                   DEFAULT
                   -> GHC.CString.unpackAppendCString# "lose"# ConnectN.main_n1
                   0 -> GHC.CString.unpackAppendCString# "draw"# ConnectN.main_n1
                   1 -> GHC.CString.unpackAppendCString# "win"# ConnectN.main_n1 }) -}
99ef8f720b3e6360ba0adf6daf886cde
  main8 :: GHC.Base.String
  {- Unfolding: (GHC.Show.showList__
                   @ GHC.Types.Int
                   GHC.Show.shows7
                   ConnectN.main_optimalMoves
                   (GHC.Types.[] @ GHC.Types.Char)) -}
059f32516c83852d7aaa374eae35a719
  main9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "For a game of Connect"#
                   ConnectN.main10) -}
e5ae4120d713b0cef9e7eb03940e8c2e
  main_a4 ::
    [[ConnectN.Move]]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [[ConnectN.Move]] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
c784804edaaff5d7671d7e19dd7c9316
  main_n :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "\n"#) -}
511d7afc8421f8cffcad7ff64d89ec83
  main_n1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "s : "#
                   ConnectN.main8) -}
2851dff876eb62159c13285a4b021b3f
  main_optimalMoves :: [ConnectN.Move]
  {- Unfolding: (case ConnectN.$wgo 1 of ww { (#,#) ww1 ww2 ->
                 case ConnectN.main_a4
                        (GHC.Types.: @ [ConnectN.Move] ww1 ww2)
                        GHC.Prim.realWorld# of ds { (#,#) ipv ipv1 ->
                 Logic.GameLogic.argsup @ [ConnectN.Move] ipv1 ConnectN.p } }) -}
998909560d595da9203981d1bdb0f7d3
  movesToBoard :: [ConnectN.Move] -> ConnectN.Board
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ moves :: [ConnectN.Move] ->
                 ConnectN.movesToBoard_go
                   ConnectN.movesToBoard_players
                   moves
                   (GHC.Types.[] @ ConnectN.Position)) -}
c884e7bf94622f5ee994783196c53c12
  movesToBoard1 :: [ConnectN.Player]
  {- HasNoCafRefs, Strictness: m2 -}
d0d3b6a12c971199999c8fb34891b6e6
  movesToBoard_go ::
    [ConnectN.Player]
    -> [GHC.Types.Int] -> ConnectN.Board -> ConnectN.Board
  {- Arity: 3, Strictness: <S,1*U><L,1*U><S,U> -}
1094eacecaa3024449a0669c521d56cc
  movesToBoard_players :: [ConnectN.Player]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ConnectN.Player
                   ConnectN.X
                   ConnectN.movesToBoard1) -}
e95f61abeffe84217dcad0dd8b2ecbeb
  optimalOutcome :: ConnectN.R
  {- Unfolding: (case ConnectN.$wvalue
                        ConnectN.optimalOutcome1 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
39cdd89d50a862e3cf3ec1799dee97e2
  optimalOutcome1 :: ConnectN.Board
  {- Unfolding: (ConnectN.movesToBoard_go
                   ConnectN.movesToBoard_players
                   ConnectN.optimalPlay
                   (GHC.Types.[] @ ConnectN.Position)) -}
34f057a53ef6a165ec4d18f5e00fede5
  optimalPlay :: [ConnectN.Move]
  {- Unfolding: (ConnectN.optimalPlay1 ConnectN.p) -}
c41f8cf15839598962dcfa055f077fad
  optimalPlay1 :: Logic.GameLogic.J ConnectN.R [ConnectN.Move]
  {- Unfolding: (Logic.GameLogic.bigotimes
                   @ ConnectN.Move
                   @ ConnectN.R
                   ConnectN.epsilons') -}
1e08524bc61288d6137e0ab2581de90c
  p :: [ConnectN.Move] -> ConnectN.R
  {- Arity: 1, Strictness: <L,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ ms :: [ConnectN.Move] ->
                 ConnectN.value (ConnectN.movesToBoard ms)) -}
2806c52d346d6b39d7a33e7e4807e4a1
  pPar :: [ConnectN.Move] -> [ConnectN.Move] -> ConnectN.R
  {- Arity: 2, Strictness: <L,1*U><L,1*U>m,
     Unfolding: InlineRule (2, True, False)
                (\ preceding :: [ConnectN.Move] ms :: [ConnectN.Move] ->
                 ConnectN.value
                   (ConnectN.movesToBoard
                      (GHC.Base.augment
                         @ GHC.Types.Int
                         (\ @ b c :: GHC.Types.Int -> b -> b[OneShot] n :: b[OneShot] ->
                          GHC.Base.foldr @ GHC.Types.Int @ b c n preceding)
                         ms))) -}
cef8e2b0ab49c8f583bcb9e32bf19d23
  parEpsilons ::
    [ConnectN.Move]
    -> [[ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ preceding :: [ConnectN.Move] ->
                 let {
                   poolOfMoves :: [GHC.Types.Int]
                   = Data.OldList.sortBy
                       @ GHC.Types.Int
                       GHC.Classes.compareInt
                       (Data.OldList.\\
                          @ GHC.Types.Int
                          GHC.Classes.$fEqInt
                          ConnectN.parEpsilons1
                          preceding)
                 } in
                 case GHC.List.$wlenAcc
                        @ GHC.Types.Int
                        poolOfMoves
                        0 of ww2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0 ww2) of wild {
                   GHC.Types.False
                   -> GHC.Types.[]
                        @ ([ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move)
                   GHC.Types.True
                   -> case GHC.List.$wlenAcc
                             @ GHC.Types.Int
                             preceding
                             0 of ww1 { DEFAULT ->
                      let {
                        epsilonO2 :: [GHC.Types.Int]
                                     -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int
                          {- Arity: 1, Strictness: <L,1*U> -}
                        = \ h :: [GHC.Types.Int] ->
                          let {
                            xs :: [GHC.Types.Int] = Logic.GameLogic.epsilons_go h poolOfMoves
                          } in
                          \ p1 :: GHC.Types.Int -> GHC.Types.Int ->
                          Logic.GameLogic.argsup
                            @ GHC.Types.Int
                            xs
                            (\ x1 :: GHC.Types.Int ->
                             case p1 x1 of wild1 { GHC.Types.I# x2 ->
                             GHC.Types.I# (GHC.Prim.negateInt# x2) })
                      } in
                      let {
                        epsilonX :: [GHC.Types.Int]
                                    -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int
                          {- Arity: 1, Strictness: <L,1*U>,
                             Unfolding: InlineRule (1, True, False)
                                        (\ h :: [GHC.Types.Int] ->
                                         Logic.GameLogic.argsup
                                           @ GHC.Types.Int
                                           (Logic.GameLogic.epsilons_go h poolOfMoves)) -}
                        = \ h :: [GHC.Types.Int] ->
                          Logic.GameLogic.argsup
                            @ GHC.Types.Int
                            (Logic.GameLogic.epsilons_go h poolOfMoves)
                      } in
                      letrec {
                        all :: [[GHC.Types.Int]
                                -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int]
                        = GHC.Types.:
                            @ ([GHC.Types.Int]
                               -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int)
                            epsilonX
                            a1
                        a1 :: [[GHC.Types.Int]
                               -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int]
                        = GHC.Types.:
                            @ ([GHC.Types.Int]
                               -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int)
                            epsilonO2
                            all
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww1 0) of wild1 {
                        GHC.Types.False
                        -> GHC.List.$wunsafeTake
                             @ ([ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move)
                             ww2
                             (ConnectN.$wunsafeDrop
                                @ ([GHC.Types.Int]
                                   -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int)
                                ww1
                                all)
                        GHC.Types.True
                        -> GHC.List.$wunsafeTake
                             @ ([ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move)
                             ww2
                             all } } } }) -}
7c45b16549548ee6ae3c3db763e8e3ca
  parEpsilons1 :: [GHC.Types.Int]
  {- Unfolding: (ConnectN.$wxs3 3) -}
ef27c83e1588b674297fae190276222a
  parOptimalPlay :: [ConnectN.Move] -> [ConnectN.Move]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ moves :: [ConnectN.Move] ->
                 GHC.Base.++
                   @ GHC.Types.Int
                   moves
                   (Logic.GameLogic.bigotimes
                      @ ConnectN.Move
                      @ ConnectN.R
                      (ConnectN.parEpsilons moves)
                      (ConnectN.pPar moves))) -}
07d0b477718106e3987d33b26dce4adf
  parShowOptimalPlay :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                ConnectN.main1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
380b1de37479149e5d41dd17998c2b8f
  prettyPrint :: ConnectN.Board -> GHC.Base.String
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ b :: ConnectN.Board ->
                 letrec {
                   go3 :: [GHC.Types.Int]
                          -> [[(ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)]]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [GHC.Types.Int] ->
                     case ds of wild {
                       []
                       -> GHC.Types.[]
                            @ [(ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)]
                       : y ys
                       -> GHC.Types.:
                            @ [(ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)]
                            (letrec {
                               go4 :: [(ConnectN.X, GHC.Types.Int, ConnectN.Player)]
                                      -> [(ConnectN.X,
                                           GHC.Types.Int,
                                           GHC.Base.Maybe ConnectN.Player)]
                                 {- Arity: 1, Strictness: <S,1*U> -}
                               = \ ds1 :: [(ConnectN.X, GHC.Types.Int, ConnectN.Player)] ->
                                 case ds1 of wild1 {
                                   []
                                   -> GHC.Types.[]
                                        @ (ConnectN.X,
                                           GHC.Types.Int,
                                           GHC.Base.Maybe ConnectN.Player)
                                   : y1 ys1
                                   -> case y1 of wild2 { (,,) ds2 y' ds3 ->
                                      case y' of wild3 { GHC.Types.I# x1 ->
                                      case y of wild4 { GHC.Types.I# y2 ->
                                      case GHC.Prim.tagToEnum#
                                             @ GHC.Types.Bool
                                             (GHC.Prim.==# x1 y2) of wild5 {
                                        GHC.Types.False -> go4 ys1
                                        GHC.Types.True
                                        -> GHC.Types.:
                                             @ (ConnectN.X,
                                                GHC.Types.Int,
                                                GHC.Base.Maybe ConnectN.Player)
                                             (ds2, wild3, GHC.Base.Just @ ConnectN.Player ds3)
                                             (go4 ys1) } } } } }
                             } in
                             Data.OldList.sortBy
                               @ (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
                               ConnectN.prettyPrint_order
                               (Data.OldList.unionBy
                                  @ (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
                                  ConnectN.prettyPrint_isBlank
                                  (go4 b)
                                  (GHC.List.zip3
                                     @ ConnectN.X
                                     @ ConnectN.Y
                                     @ (GHC.Base.Maybe ConnectN.Player)
                                     ConnectN.prettyPrint7
                                     (GHC.List.repeat @ GHC.Types.Int y)
                                     ConnectN.prettyPrint_xs)))
                            (go3 ys) }
                 } in
                 case GHC.Base.map
                        @ [(ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)]
                        @ [GHC.Types.Char]
                        ConnectN.prettyPrint3
                        (GHC.List.reverse1
                           @ [(ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)]
                           (go3 ConnectN.prettyPrint7)
                           (GHC.Types.[]
                              @ [(ConnectN.X,
                                  ConnectN.Y,
                                  GHC.Base.Maybe ConnectN.Player)])) of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : x1 xs1
                   -> Data.OldList.intercalate_$spoly_go
                        @ GHC.Types.Char
                        x1
                        (Data.OldList.prependToAll
                           @ [GHC.Types.Char]
                           ConnectN.prettyPrint1
                           xs1) }) -}
12aecf369a9f2da3f81997d03224fb63
  prettyPrint1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "\n"#
                   ConnectN.prettyPrint2) -}
c3091a4b1387507d242dd80359e33ad3
  prettyPrint2 :: [GHC.Types.Char]
  {- Unfolding: (ConnectN.$wxs2 3) -}
730c519cf61e521f9181ab92f411c53f
  prettyPrint3 ::
    [(ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)]
    -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ x1 :: [(ConnectN.X,
                           ConnectN.Y,
                           GHC.Base.Maybe ConnectN.Player)] ->
                 GHC.CString.unpackAppendCString#
                   "  "#
                   (case GHC.Base.map
                           @ (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
                           @ [GHC.Types.Char]
                           ConnectN.prettyPrint5
                           x1 of wild {
                      [] -> GHC.Types.[] @ GHC.Types.Char
                      : x2 xs1
                      -> Data.OldList.intercalate_$spoly_go
                           @ GHC.Types.Char
                           x2
                           (Data.OldList.prependToAll
                              @ [GHC.Types.Char]
                              ConnectN.prettyPrint4
                              xs1) })) -}
a40c81aa58938617c0fa6177ee9499b4
  prettyPrint4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " | "#) -}
28c5b60ff64c7bc5bf420893db1a3e52
  prettyPrint5 ::
    (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
    -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: (ConnectN.X,
                          ConnectN.Y,
                          GHC.Base.Maybe ConnectN.Player) ->
                 case ds of wild { (,,) ds1 ds2 p1 ->
                 case p1 of wild1 {
                   GHC.Base.Nothing -> ConnectN.prettyPrint6
                   GHC.Base.Just x1
                   -> case x1 of wild2 {
                        ConnectN.X -> ConnectN.$fReadPlayer11
                        ConnectN.O -> ConnectN.$fReadPlayer8 } } }) -}
15dc274c4784c8a6b12e724adc3f91d3
  prettyPrint6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " "#) -}
103517e793502b22bdcbce81d71b0c9b
  prettyPrint7 :: [GHC.Types.Int]
  {- Unfolding: (GHC.Enum.eftInt 1 3) -}
b2dbefafab18f0eb67e1f8c7079e3242
  prettyPrint_isBlank ::
    (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
    -> (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U(U),1*U(U),A)><S(SLL),1*U(1*U(U),1*U(U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
                   w1 :: (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player) ->
                 case w of ww { (,,) ww1 ww2 ww3 ->
                 case ww1 of ww4 { GHC.Types.I# ww5 ->
                 case w1 of ww6 { (,,) ww7 ww8 ww9 ->
                 case ww7 of ww10 { GHC.Types.I# ww11 ->
                 ConnectN.$wisBlank ww5 ww2 ww11 ww8 ww9 } } } }) -}
4b6f3842fae3c5263472cf3ebc95e9cf
  prettyPrint_order ::
    (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
    -> (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
    -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U(U),A,A)><S(SLL),1*U(1*U(U),A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
                   ds1 :: (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player) ->
                 case ds of wild { (,,) x1 ds2 ds3 ->
                 case ds1 of wild1 { (,,) x' ds4 ds5 ->
                 GHC.Classes.compareInt x1 x' } }) -}
54babfa3419f35b7946b9a59a640e2d3
  prettyPrint_xs :: [GHC.Base.Maybe ConnectN.Player]
  {- HasNoCafRefs, Strictness: m2 -}
02cdaaf583092fc799b864f7d1309651
  showOptimalPlay :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                ConnectN.showOptimalPlay1
                  `cast`
                (Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
1a39b3392b89df6a4f2cf883402c40b7
  showOptimalPlay1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (GHC.Show.$fShow[]_$s$cshow ConnectN.optimalPlay)
                   GHC.Types.True
                   eta) -}
3973436216805a48ed4cb5f3977db8ca
  takeTurn ::
    ConnectN.Player
    -> ConnectN.Move -> ConnectN.Board -> ConnectN.Board
  {- Arity: 3, Strictness: <L,U><L,U(U)><S,U>,
     Unfolding: (\ p1 :: ConnectN.Player
                   m :: ConnectN.Move
                   b :: ConnectN.Board ->
                 letrec {
                   $wgo1 :: [(ConnectN.Move, ConnectN.Y, ConnectN.Player)]
                            -> GHC.Prim.Int# -> GHC.Prim.Int#
                     {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                   = \ w :: [(ConnectN.Move, ConnectN.Y, ConnectN.Player)]
                       ww :: GHC.Prim.Int# ->
                     case w of wild {
                       [] -> ww
                       : y ys
                       -> case y of wild1 { (,,) x1 ds ds1 ->
                          case x1 of wild2 { GHC.Types.I# x2 ->
                          case m of wild3 { GHC.Types.I# y1 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.==# x2 y1) of wild4 {
                            GHC.Types.False -> $wgo1 ys ww
                            GHC.Types.True -> $wgo1 ys (GHC.Prim.+# ww 1) } } } } }
                 } in
                 case $wgo1 b 0 of ww { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww 3) of wild {
                   GHC.Types.False -> ConnectN.takeTurn1 m b
                   GHC.Types.True
                   -> GHC.Base.++
                        @ (ConnectN.X, ConnectN.Y, ConnectN.Player)
                        b
                        (GHC.Types.:
                           @ (ConnectN.X, ConnectN.Y, ConnectN.Player)
                           (m, GHC.Types.I# (GHC.Prim.+# ww 1), p1)
                           (GHC.Types.[] @ (ConnectN.X, ConnectN.Y, ConnectN.Player))) } }) -}
a06427f13d41b6d0b1a6739946e5d306
  takeTurn1 :: ConnectN.Move -> ConnectN.Board -> ConnectN.Board
  {- Arity: 2, Strictness: <L,U><L,U>b -}
16cfeda757ca8b5555f61e2039486a46
  value :: ConnectN.Board -> ConnectN.R
  {- Arity: 1, Strictness: <L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: ConnectN.Board ->
                 case ConnectN.$wvalue w of ww { DEFAULT -> GHC.Types.I# ww }) -}
3315d90f8988227d99e672bc09bb82c0
  width :: GHC.Types.Int
  {- Strictness: m, Unfolding: (ConnectN.height) -}
5569e1eee68e4618133c161afeeb2708
  winningAmount :: GHC.Types.Int
  {- Strictness: m, Unfolding: (ConnectN.height) -}
1427e23bebd026ebe06b38b851e8ade7
  wins :: ConnectN.Player -> ConnectN.Board -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><L,U> -}
instance GHC.Classes.Eq [ConnectN.Player] = ConnectN.$fEqPlayer
instance GHC.Classes.Ord [ConnectN.Player] = ConnectN.$fOrdPlayer
instance GHC.Read.Read [ConnectN.Player] = ConnectN.$fReadPlayer
instance GHC.Show.Show [ConnectN.Player] = ConnectN.$fShowPlayer
"SPEC argmax @ Int" [ALWAYS] forall $dNFData :: Control.DeepSeq.NFData
                                                  GHC.Types.Int
                                    $dOrd :: GHC.Classes.Ord GHC.Types.Int
  ConnectN.argmax @ GHC.Types.Int $dNFData $dOrd
  = ConnectN.argmax_$sargmax
"SPEC argmin @ Int" [ALWAYS] forall $dNFData :: Control.DeepSeq.NFData
                                                  GHC.Types.Int
                                    $dOrd :: GHC.Classes.Ord GHC.Types.Int
  ConnectN.argmin @ GHC.Types.Int $dNFData $dOrd
  = ConnectN.argmin_$sargmin
"SPEC/ConnectN $dmreadsPrec @ Player" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                  ConnectN.Player
  GHC.Read.$dmreadsPrec @ ConnectN.Player $dRead
  = ConnectN.$fReadPlayer_$s$dmreadsPrec
"SPEC/ConnectN readListDefault @ Player" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                     ConnectN.Player
  GHC.Read.readListDefault @ ConnectN.Player $dRead
  = ConnectN.$fReadPlayer_$sreadListDefault
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

