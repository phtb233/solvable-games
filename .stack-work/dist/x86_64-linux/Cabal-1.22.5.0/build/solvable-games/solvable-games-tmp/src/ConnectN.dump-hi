
==================== FINAL INTERFACE ====================
2016-08-24 17:04:47.911586 UTC

interface main@main:ConnectN 7103
  interface hash: 32188508399288400fd807f827b5fbd9
  ABI hash: ff448b6a6a5cc1877637a18dbc6976c7
  export-list hash: 08de2402677dbcd8948970f0b72e10ae
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 00e643ad7ce35edfdec2c9358b896e07
  sig of: Nothing
  used TH splices: False
  where
exports:
  ConnectN.argmax
  ConnectN.argmin
  ConnectN.epsilons
  ConnectN.epsilons'
  ConnectN.height
  ConnectN.main
  ConnectN.movesToBoard
  ConnectN.optimalOutcome
  ConnectN.optimalPlay
  ConnectN.p
  ConnectN.pPar
  ConnectN.parEpsilons
  ConnectN.parOptimalPlay
  ConnectN.parShowOptimalPlay
  ConnectN.prettyPrint
  ConnectN.showOptimalPlay
  ConnectN.takeTurn
  ConnectN.value
  ConnectN.width
  ConnectN.winningAmount
  ConnectN.wins
  ConnectN.Board
  ConnectN.Move
  ConnectN.Player{ConnectN.O ConnectN.X}
  ConnectN.Position
  ConnectN.R
  ConnectN.X
  ConnectN.Y
module dependencies: Logic.GameLogic
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0 containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 parallel-3.2.1.0@paral_BEbrIfHgHtmEpYU5TfKWK9
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Control.Exception e9090e246fba030faecf7b81b3e8e320
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Enum debc6de3086023a15993ab0cecffb90b
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Read b423b4506a014855edbd329b567629f3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:System.IO 0248c1e850b7ea124cf7a2e1669ebf67
import  -/  deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59:Control.DeepSeq 269ef0c8d019d01c547937e1ae8fb2e8
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  Logic.GameLogic 26d44f799309be9333aa831cc195f912
  exports: 02a96d8251ab1656b811a49d270bd213
  J e62c617d76644dc2a111453607a27a3f
  arginf 96ecd49dd950b5b804860583045f1907
  argsup 51152ae523909382c51faca10fd8c2ff
  bigotimes 344a9cb8123787eadef3d179968b7b85
  contained 8f08fdcddaf32fb746d5118f19e84814
  setMinus 9e687f4ea98fa5bb19d6b1054c1ce9b4
import  -/  parallel-3.2.1.0@paral_BEbrIfHgHtmEpYU5TfKWK9:Control.Parallel 1b43eb56445614e8fc63261d7d1b82ab
import  -/  parallel-3.2.1.0@paral_BEbrIfHgHtmEpYU5TfKWK9:Control.Parallel.Strategies e559e49e970aa71559d76fa817ccb0ac
b00cfd8d035162fa92ab0b7b3611ee52
  $fEqPlayer :: GHC.Classes.Eq ConnectN.Player
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ConnectN.Player
                  ConnectN.$fEqPlayer_$c==
                  ConnectN.$fEqPlayer_$c/= -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fEqPlayer_$c/= ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: ConnectN.Player b :: ConnectN.Player ->
                 case a1 of wild {
                   ConnectN.X
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.False ConnectN.O -> GHC.Types.True }
                   ConnectN.O
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.True ConnectN.O -> GHC.Types.False } }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fEqPlayer_$c== ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: ConnectN.Player ds1 :: ConnectN.Player ->
                 case ds of wild {
                   ConnectN.X
                   -> case ds1 of wild1 {
                        ConnectN.X -> GHC.Types.True ConnectN.O -> GHC.Types.False }
                   ConnectN.O
                   -> case ds1 of wild1 {
                        ConnectN.X -> GHC.Types.False ConnectN.O -> GHC.Types.True } }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fOrdPlayer :: GHC.Classes.Ord ConnectN.Player
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ConnectN.Player
                  ConnectN.$fEqPlayer
                  ConnectN.$fOrdPlayer_$ccompare
                  ConnectN.$fOrdPlayer_$c<
                  ConnectN.$fOrdPlayer_$c<=
                  ConnectN.$fOrdPlayer_$c>
                  ConnectN.$fOrdPlayer_$c>=
                  ConnectN.$fOrdPlayer_$cmax
                  ConnectN.$fOrdPlayer_$cmin -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fOrdPlayer_$c< ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: ConnectN.Player b :: ConnectN.Player ->
                 case a1 of wild {
                   ConnectN.X
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.False ConnectN.O -> GHC.Types.True }
                   ConnectN.O -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fOrdPlayer_$c<= ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: ConnectN.Player b :: ConnectN.Player ->
                 case a1 of wild {
                   ConnectN.X -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   ConnectN.O
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.False ConnectN.O -> GHC.Types.True } }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fOrdPlayer_$c> ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: ConnectN.Player b :: ConnectN.Player ->
                 case a1 of wild {
                   ConnectN.X -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   ConnectN.O
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.True ConnectN.O -> GHC.Types.False } }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fOrdPlayer_$c>= ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: ConnectN.Player b :: ConnectN.Player ->
                 case a1 of wild {
                   ConnectN.X
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.True ConnectN.O -> GHC.Types.False }
                   ConnectN.O -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fOrdPlayer_$ccompare ::
    ConnectN.Player -> ConnectN.Player -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: ConnectN.Player b :: ConnectN.Player ->
                 case a1 of wild {
                   ConnectN.X
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.EQ ConnectN.O -> GHC.Types.LT }
                   ConnectN.O
                   -> case b of wild1 {
                        ConnectN.X -> GHC.Types.GT ConnectN.O -> GHC.Types.EQ } }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fOrdPlayer_$cmax ::
    ConnectN.Player -> ConnectN.Player -> ConnectN.Player
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x1 :: ConnectN.Player y :: ConnectN.Player ->
                 case x1 of wild {
                   ConnectN.X -> y
                   ConnectN.O -> case y of wild1 { DEFAULT -> ConnectN.O } }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fOrdPlayer_$cmin ::
    ConnectN.Player -> ConnectN.Player -> ConnectN.Player
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x1 :: ConnectN.Player y :: ConnectN.Player ->
                 case x1 of wild {
                   ConnectN.X -> case y of wild1 { DEFAULT -> ConnectN.X }
                   ConnectN.O -> y }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer :: GHC.Read.Read ConnectN.Player
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ConnectN.Player
                  ConnectN.$fReadPlayer_$s$dmreadsPrec
                  ConnectN.$fReadPlayer_$sreadListDefault
                  ConnectN.$fReadPlayer_$creadPrec
                  ConnectN.$fReadPlayer_$creadListPrec -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([ConnectN.Player] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [ConnectN.Player] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ ConnectN.Player
                   ConnectN.$fReadPlayer2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <ConnectN.Player>_R))
                   @ b
                   eta1) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (ConnectN.Player -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: ConnectN.Player -> Text.ParserCombinators.ReadP.P b ->
                 eta ConnectN.X) -}
df157d8d09343247225c2c79cc7b4615
  $fReadPlayer11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "X"#) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP ConnectN.Player
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ ConnectN.Player
                   ConnectN.$fReadPlayer3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <ConnectN.Player>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <ConnectN.Player>_R)))) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (ConnectN.Player -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: ConnectN.Player -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ ConnectN.Player
                   ConnectN.$fReadPlayer4
                   eta
                   @ b
                   eta1) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player)
                   ConnectN.$fReadPlayer9
                   ConnectN.$fReadPlayer5) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player)
                   ConnectN.$fReadPlayer6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player))) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player)
  {- Strictness: m,
     Unfolding: ((ConnectN.$fReadPlayer8,
                  ConnectN.$fReadPlayer7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <ConnectN.Player>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <ConnectN.Player>_R))))) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (ConnectN.Player -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: ConnectN.Player -> Text.ParserCombinators.ReadP.P b ->
                 eta ConnectN.O) -}
6e6d975ae9f719bef576edaadaf3bac3
  $fReadPlayer8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "O"#) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player)
  {- Strictness: m,
     Unfolding: ((ConnectN.$fReadPlayer11,
                  ConnectN.$fReadPlayer10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <ConnectN.Player>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <ConnectN.Player>_R))))) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [ConnectN.Player]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                ConnectN.$fReadPlayer1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[ConnectN.Player]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[ConnectN.Player]>_R))) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec ConnectN.Player
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                ConnectN.$fReadPlayer2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <ConnectN.Player>_R)) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer_$s$dmreadsPrec ::
    GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS ConnectN.Player
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ ConnectN.Player
                   ConnectN.$fReadPlayer_$creadPrec
                   eta) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fReadPlayer_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [ConnectN.Player]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [ConnectN.Player]
                   ((ConnectN.$fReadPlayer_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[ConnectN.Player]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <[ConnectN.Player]>_R)
                      @ [ConnectN.Player]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [ConnectN.Player]))) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fShowPlayer :: GHC.Show.Show ConnectN.Player
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ConnectN.Player
                  ConnectN.$fShowPlayer_$cshowsPrec
                  ConnectN.$fShowPlayer_$cshow
                  ConnectN.$fShowPlayer_$cshowList -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fShowPlayer1 :: ConnectN.Player -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: ConnectN.Player eta :: GHC.Base.String ->
                 case ds of wild {
                   ConnectN.X
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n1 :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n1 ConnectN.$fReadPlayer11)
                        eta
                   ConnectN.O
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n1 :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n1 ConnectN.$fReadPlayer8)
                        eta }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fShowPlayer_$cshow :: ConnectN.Player -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x1 :: ConnectN.Player ->
                 case x1 of wild {
                   ConnectN.X -> ConnectN.$fReadPlayer11
                   ConnectN.O -> ConnectN.$fReadPlayer8 }) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fShowPlayer_$cshowList :: [ConnectN.Player] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ ConnectN.Player
                   ConnectN.$fShowPlayer1) -}
b00cfd8d035162fa92ab0b7b3611ee52
  $fShowPlayer_$cshowsPrec ::
    GHC.Types.Int -> ConnectN.Player -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: ConnectN.Player
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   ConnectN.X
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n1 :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n1 ConnectN.$fReadPlayer11)
                        eta
                   ConnectN.O
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n1 :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n1 ConnectN.$fReadPlayer8)
                        eta }) -}
8ab2f7189bfdfd0edf502c77ff262072
  $wgo :: GHC.Prim.Int# -> (# [ConnectN.Move], [[ConnectN.Move]] #)
  {- Arity: 1, Strictness: <L,U>, Inline: [0] -}
5786e25b6998efa9d60a0eb4eafd250c
  $wisBlank ::
    GHC.Prim.Int#
    -> ConnectN.Y
    -> GHC.Prim.Int#
    -> ConnectN.Y
    -> GHC.Base.Maybe ConnectN.Player
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: ConnectN.Y
                   ww2 :: GHC.Prim.Int#
                   ww3 :: ConnectN.Y
                   ww4 :: GHC.Base.Maybe ConnectN.Player ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Types.I# x1 ->
                      case ww3 of wild2 { GHC.Types.I# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x1 y) of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> Data.Maybe.isNothing @ ConnectN.Player ww4 } } } }) -}
addbb15bd850c9389bc219ff1d9b5d76
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
b2e4030796aeaf6ce03f151b7c6f4675
  $wvalue :: ConnectN.Board -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ w :: ConnectN.Board ->
                 case ConnectN.wins ConnectN.X w of wild {
                   GHC.Types.False
                   -> case ConnectN.wins ConnectN.O w of wild1 {
                        GHC.Types.False -> 0 GHC.Types.True -> (-1) }
                   GHC.Types.True -> 1 }) -}
d8557d99d23f9bf5761f18f0531b5fb7
  $wxs :: GHC.Prim.Int# -> [GHC.Types.Int]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
2cfa72c50dd009bcaaa9dc9beb8b2632
  $wxs1 :: GHC.Prim.Int# -> [GHC.Types.Int]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
1b9fd200ba3648f50524812cda415283
  $wxs2 :: GHC.Prim.Int# -> [GHC.Types.Int]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
b80044623f406e4ff74d78bd856a801d
  $wxs3 :: GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
f94d9642c413c5bc286d3b26a561e6a5
  type Board = [ConnectN.Position]
f6732f5e1ddc64e1de69ae471e9e69e2
  type Move = GHC.Types.Int
b00cfd8d035162fa92ab0b7b3611ee52
  data Player = X | O
    Promotable
ae3792e5515e94b167dd948b13d3b3f4
  type Position = (ConnectN.X, ConnectN.Y, ConnectN.Player)
35e85e55bd7532d12206eff38fd7f9f6
  type R = GHC.Types.Int
1a3d51d5bc0c9c08957c003393c0a5d3
  type X = GHC.Types.Int
97c037883fb87ba9d346c5cab1838b08
  type Y = GHC.Types.Int
4ed4d303dfa985dbd9a3e65c3794e1a8
  argmax ::
    (Control.DeepSeq.NFData a, GHC.Classes.Ord a) =>
    [a] -> (a -> GHC.Types.Int) -> [a]
  {- Arity: 4,
     Strictness: <L,C(U)><L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><L,C(U)>,
     Unfolding: (\ @ a1
                   $dNFData :: Control.DeepSeq.NFData a1
                   $dOrd :: GHC.Classes.Ord a1
                   eta :: [a1]
                   eta1 :: a1 -> GHC.Types.Int ->
                 case eta of wild {
                   [] -> ConnectN.argmax5 @ a1
                   : ipv ipv1
                   -> let {
                        graph :: [(GHC.Types.Int, a1)]
                        = Data.OldList.sortBy
                            @ (GHC.Types.Int, a1)
                            (\ w3 :: (GHC.Types.Int, a1) w4 :: (GHC.Types.Int, a1)[OneShot] ->
                             case w3 of ww { (,) ww1 ww2 ->
                             case w4 of ww3 { (,) ww4 ww5 ->
                             case ww1 of wild1 { GHC.Types.I# x# ->
                             case ww4 of wild2 { GHC.Types.I# y# ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.<# x# y#) of wild3 {
                               GHC.Types.False
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.==# x# y#) of wild4 {
                                    GHC.Types.False -> GHC.Types.GT
                                    GHC.Types.True -> GHC.Classes.compare @ a1 $dOrd ww2 ww5 }
                               GHC.Types.True -> GHC.Types.LT } } } } })
                            (Control.Parallel.Strategies.parMap
                               @ (GHC.Types.Int, a1)
                               @ a1
                               (\ x1 :: (GHC.Types.Int, a1)
                                  eta2 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                                case GHC.Prim.seq#
                                       @ ()
                                       @ GHC.Prim.RealWorld
                                       (case x1 of wild1 { (,) x2 y ->
                                        case x2 of ds1 { GHC.Types.I# ipv2 ->
                                        $dNFData `cast` (Control.DeepSeq.NTCo:NFData[0] <a1>_N)
                                          y } })
                                       eta2 of ds { (#,#) ipv2 ipv3 ->
                                (# ipv2, x1 #) })
                                 `cast`
                               (<(GHC.Types.Int, a1)>_R
                                ->_R Sym (Control.Parallel.Strategies.NTCo:Eval[0]
                                              <(GHC.Types.Int, a1)>_R))
                               (\ x1 :: a1 -> (eta1 x1, x1))
                               wild)
                      } in
                      let {
                        lvl16 :: GHC.Types.Int
                        = case ConnectN.argmax4
                                 @ a1
                                 graph
                                 (GHC.List.lastError @ (GHC.Types.Int, a1)) of wild1 { (,) x1 ds1 ->
                          x1 }
                      } in
                      letrec {
                        go3 :: [(GHC.Types.Int, a1)] -> [a1]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ ds :: [(GHC.Types.Int, a1)] ->
                          case ds of wild1 {
                            [] -> GHC.Types.[] @ a1
                            : y ys
                            -> case y of wild2 { (,) v x1 ->
                               case v of wild3 { GHC.Types.I# x2 ->
                               case lvl16 of wild4 { GHC.Types.I# y1 ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.==# x2 y1) of wild5 {
                                 GHC.Types.False -> go3 ys
                                 GHC.Types.True -> GHC.Types.: @ a1 x1 (go3 ys) } } } } }
                      } in
                      go3 graph }) -}
b9254784ce5f40623df113fa180b6afc
  argmax1 ::
    (GHC.Types.Int, GHC.Types.Int)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (GHC.Types.Int, GHC.Types.Int) #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U,U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x1 :: (GHC.Types.Int, GHC.Types.Int)
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.Prim.seq#
                        @ ()
                        @ GHC.Prim.RealWorld
                        (case x1 of wild { (,) x2 y ->
                         case x2 of ds1 { GHC.Types.I# ipv ->
                         case y of ds2 { GHC.Types.I# ipv1 -> GHC.Tuple.() } } })
                        eta of ds { (#,#) ipv ipv1 ->
                 (# ipv, x1 #) }) -}
6875304a6e2d9464c0a0a217b4726676
  argmax2 ::
    (GHC.Types.Int, GHC.Types.Int)
    -> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (\ w3 :: (GHC.Types.Int, GHC.Types.Int)
                   w4 :: (GHC.Types.Int, GHC.Types.Int)[OneShot] ->
                 case w3 of ww { (,) ww1 ww2 ->
                 case w4 of ww3 { (,) ww4 ww5 ->
                 case ww1 of wild { GHC.Types.I# x# ->
                 case ww4 of wild1 { GHC.Types.I# y# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# x# y#) of wild2 {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x# y#) of wild3 {
                        GHC.Types.False -> GHC.Types.GT
                        GHC.Types.True -> GHC.Classes.compareInt ww2 ww5 }
                   GHC.Types.True -> GHC.Types.LT } } } } }) -}
38cf678988443ef1ba922af48a4c9c32
  argmax3 :: [GHC.Types.Int]
  {- Strictness: b -}
f98b84052ef6b5dd38100c1fe8e997d3
  argmax4 ::
    [(GHC.Types.Int, a)] -> (GHC.Types.Int, a) -> (GHC.Types.Int, a)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U,U)> -}
99fd0fb0ab09f2611406e24fc080c33d
  argmax5 :: [a]
  {- Strictness: b -}
38b9794d53fba8276c6346957706c1e9
  argmax_$sargmax ::
    [GHC.Types.Int]
    -> (GHC.Types.Int -> GHC.Types.Int) -> [GHC.Types.Int]
  {- Arity: 2, Strictness: <S,1*U><L,C(U)>,
     Unfolding: (\ eta :: [GHC.Types.Int]
                   eta1 :: GHC.Types.Int -> GHC.Types.Int ->
                 case eta of wild {
                   [] -> ConnectN.argmax3
                   : ipv ipv1
                   -> let {
                        graph :: [(GHC.Types.Int, GHC.Types.Int)]
                        = Data.OldList.sortBy
                            @ (GHC.Types.Int, GHC.Types.Int)
                            ConnectN.argmax2
                            (Control.Parallel.Strategies.parMap
                               @ (GHC.Types.Int, GHC.Types.Int)
                               @ GHC.Types.Int
                               ConnectN.argmax1
                                 `cast`
                               (<(GHC.Types.Int, GHC.Types.Int)>_R
                                ->_R Sym (Control.Parallel.Strategies.NTCo:Eval[0]
                                              <(GHC.Types.Int, GHC.Types.Int)>_R))
                               (\ x1 :: GHC.Types.Int -> (eta1 x1, x1))
                               wild)
                      } in
                      let {
                        lvl16 :: GHC.Types.Int
                        = case ConnectN.argmax_go
                                 graph
                                 (GHC.List.lastError
                                    @ (GHC.Types.Int, GHC.Types.Int)) of wild1 { (,) x1 ds1 ->
                          x1 }
                      } in
                      letrec {
                        go3 :: [(GHC.Types.Int, GHC.Types.Int)] -> [GHC.Types.Int]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ ds :: [(GHC.Types.Int, GHC.Types.Int)] ->
                          case ds of wild1 {
                            [] -> GHC.Types.[] @ GHC.Types.Int
                            : y ys
                            -> case y of wild2 { (,) v x1 ->
                               case v of wild3 { GHC.Types.I# x2 ->
                               case lvl16 of wild4 { GHC.Types.I# y1 ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.==# x2 y1) of wild5 {
                                 GHC.Types.False -> go3 ys
                                 GHC.Types.True -> GHC.Types.: @ GHC.Types.Int x1 (go3 ys) } } } } }
                      } in
                      go3 graph }) -}
d157a6aa3e2561e930fa263a7302c23f
  argmax_go ::
    [(GHC.Types.Int, GHC.Types.Int)]
    -> (GHC.Types.Int, GHC.Types.Int) -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U,U)> -}
1d1f8a50c8fce5ce0565ef8f4836101b
  argmin ::
    (Control.DeepSeq.NFData a, GHC.Classes.Ord a) =>
    [a] -> (a -> GHC.Types.Int) -> [a]
  {- Arity: 4,
     Strictness: <L,C(U)><L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><L,C(U(U))>,
     Unfolding: (\ @ a1
                   $dNFData :: Control.DeepSeq.NFData a1
                   $dOrd :: GHC.Classes.Ord a1
                   ds :: [a1]
                   ds1 :: a1 -> GHC.Types.Int ->
                 case ds of wild {
                   [] -> ConnectN.argmin2 @ a1
                   : ipv ipv1
                   -> ConnectN.argmax
                        @ a1
                        $dNFData
                        $dOrd
                        wild
                        (\ x1 :: a1 ->
                         case ds1 x1 of wild1 { GHC.Types.I# x2 ->
                         GHC.Types.I# (GHC.Prim.negateInt# x2) }) }) -}
3033cb1072675a37e4399342d0e0daa8
  argmin1 :: [GHC.Types.Int]
  {- Strictness: b -}
d5349e99a01ad6f121f39b34fbbb978e
  argmin2 :: [a]
  {- Strictness: b -}
ad822f3cff222b779287f714cb3a81c6
  argmin_$sargmin ::
    [GHC.Types.Int]
    -> (GHC.Types.Int -> GHC.Types.Int) -> [GHC.Types.Int]
  {- Arity: 2, Strictness: <S,1*U><L,C(U(U))>,
     Unfolding: (\ ds :: [GHC.Types.Int]
                   ds1 :: GHC.Types.Int -> GHC.Types.Int ->
                 case ds of wild {
                   [] -> ConnectN.argmin1
                   : ipv ipv1
                   -> ConnectN.argmax_$sargmax
                        wild
                        (\ x1 :: GHC.Types.Int ->
                         case ds1 x1 of wild1 { GHC.Types.I# x2 ->
                         GHC.Types.I# (GHC.Prim.negateInt# x2) }) }) -}
991d0be44da36dcb0e4dabbb04f12f62
  epsilons ::
    [[ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move]
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ GHC.Types.Int
                        ConnectN.epsilons_poolOfMoves
                        0 of ww2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0 ww2) of wild {
                   GHC.Types.False
                   -> GHC.Types.[]
                        @ ([ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move)
                   GHC.Types.True
                   -> GHC.List.$wunsafeTake
                        @ ([ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move)
                        ww2
                        ConnectN.epsilons_all } }) -}
901e823ea5fa74db5f2ea70fc04b5e61
  epsilons' ::
    [[ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move]
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ GHC.Types.Int
                        ConnectN.epsilons'_poolOfMoves
                        0 of ww2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0 ww2) of wild {
                   GHC.Types.False
                   -> GHC.Types.[]
                        @ ([ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move)
                   GHC.Types.True
                   -> GHC.List.$wunsafeTake
                        @ ([ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move)
                        ww2
                        ConnectN.epsilons'_all' } }) -}
a89e8ec796bd22567d61e94655981b5a
  epsilons'1 ::
    [[GHC.Types.Int]
     -> (GHC.Types.Int -> GHC.Types.Int) -> GHC.Types.Int]
  {- Strictness: m2 -}
14ee71638956fa08a53bd60fda6d64aa
  epsilons'2 :: [GHC.Types.Int]
  {- Unfolding: (ConnectN.$wxs1 3) -}
d13e1a0f5bfc1f29e0b5e39e8e2a6d63
  epsilons'_all' ::
    [[GHC.Types.Int]
     -> (GHC.Types.Int -> GHC.Types.Int) -> GHC.Types.Int]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ([GHC.Types.Int]
                      -> (GHC.Types.Int -> GHC.Types.Int) -> GHC.Types.Int)
                   ConnectN.epsilons'_epsilonX'
                   ConnectN.epsilons'1) -}
b69559fd4d1d8de12310b0920f82d7f3
  epsilons'_epsilonX' ::
    [GHC.Types.Int]
    -> (GHC.Types.Int -> GHC.Types.Int) -> GHC.Types.Int
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ h :: [GHC.Types.Int] ->
                 let {
                   a1 :: [Logic.GameLogic.Move]
                   = Logic.GameLogic.epsilons_go h ConnectN.epsilons'_poolOfMoves
                 } in
                 \ x1 :: GHC.Types.Int -> GHC.Types.Int ->
                 case ConnectN.argmax_$sargmax a1 x1 of wild {
                   [] -> GHC.List.badHead @ GHC.Types.Int : x2 ds1 -> x2 }) -}
bba3d5179c79d68f389504158f21f86f
  epsilons'_poolOfMoves :: [GHC.Types.Int]
  {- Unfolding: (Data.OldList.sortBy
                   @ GHC.Types.Int
                   GHC.Classes.compareInt
                   ConnectN.epsilons'2) -}
34a6aca2a4c314f957ce89e1a01d91e3
  epsilons1 ::
    [[GHC.Types.Int] -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int]
  {- Strictness: m2 -}
8e7e8312641cbbbeefc8da999363adec
  epsilons2 :: [GHC.Types.Int]
  {- Unfolding: (ConnectN.$wxs 3) -}
f9c7ca2b999545a85164832f1850d4de
  epsilons_all ::
    [[GHC.Types.Int] -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ([GHC.Types.Int]
                      -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int)
                   ConnectN.epsilons_epsilonX
                   ConnectN.epsilons1) -}
23ddbc0655fcbaf518b3b9274cfd4362
  epsilons_epsilonX ::
    [GHC.Types.Int] -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ h :: [GHC.Types.Int] ->
                 Logic.GameLogic.argsup
                   @ GHC.Types.Int
                   (Logic.GameLogic.epsilons_go h ConnectN.epsilons_poolOfMoves)) -}
d1403f167117484e481488b99614ed61
  epsilons_poolOfMoves :: [GHC.Types.Int]
  {- Unfolding: (Data.OldList.sortBy
                   @ GHC.Types.Int
                   GHC.Classes.compareInt
                   ConnectN.epsilons2) -}
ffd372863d63a31fddf3e05b08239c9e
  height :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 3) -}
9eddeb4eb907bdce5e33415fb77905f7
  main :: [ConnectN.Move] -> [ConnectN.Move]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True) ConnectN.parOptimalPlay -}
d64e2739df8de6c194cee86d25294030
  movesToBoard :: [ConnectN.Move] -> ConnectN.Board
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ moves :: [ConnectN.Move] ->
                 ConnectN.movesToBoard_go
                   ConnectN.movesToBoard_players
                   moves
                   (GHC.Types.[] @ ConnectN.Position)) -}
c6bcb8683ecf8c1d9d3a778a858145a2
  movesToBoard1 :: [ConnectN.Player]
  {- HasNoCafRefs, Strictness: m2 -}
c1c52f682629c09158f11854cf3b65c0
  movesToBoard_go ::
    [ConnectN.Player]
    -> [GHC.Types.Int] -> ConnectN.Board -> ConnectN.Board
  {- Arity: 3, Strictness: <S,1*U><L,1*U><S,U> -}
b2afa1c1fd5334cbfd7eecafb62f2b89
  movesToBoard_players :: [ConnectN.Player]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ConnectN.Player
                   ConnectN.X
                   ConnectN.movesToBoard1) -}
91995d1e5c0f209a59542c75fc2735de
  optimalOutcome :: ConnectN.R
  {- Unfolding: (case ConnectN.$wvalue
                        ConnectN.optimalOutcome1 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
5d21a5320f2ab3dd126448f69341c91e
  optimalOutcome1 :: ConnectN.Board
  {- Unfolding: (ConnectN.movesToBoard_go
                   ConnectN.movesToBoard_players
                   ConnectN.optimalPlay
                   (GHC.Types.[] @ ConnectN.Position)) -}
3ee04c3c6080776e2e70a3f00be55720
  optimalPlay :: [ConnectN.Move]
  {- Unfolding: (ConnectN.optimalPlay1 ConnectN.p) -}
75317d20c16039193329debe8d06b740
  optimalPlay1 :: Logic.GameLogic.J ConnectN.R [ConnectN.Move]
  {- Unfolding: (Logic.GameLogic.bigotimes
                   @ ConnectN.Move
                   @ ConnectN.R
                   ConnectN.epsilons) -}
e0af485137329f2c8e53d4e2e8db9c48
  p :: [ConnectN.Move] -> ConnectN.R
  {- Arity: 1, Strictness: <L,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ ms :: [ConnectN.Move] ->
                 ConnectN.value (ConnectN.movesToBoard ms)) -}
225e613316087bc7d61eb861b61d85fb
  pPar :: [ConnectN.Move] -> [ConnectN.Move] -> ConnectN.R
  {- Arity: 2, Strictness: <L,1*U><L,1*U>m,
     Unfolding: InlineRule (2, True, False)
                (\ preceding :: [ConnectN.Move] ms :: [ConnectN.Move] ->
                 ConnectN.value
                   (ConnectN.movesToBoard
                      (GHC.Base.augment
                         @ GHC.Types.Int
                         (\ @ b c :: GHC.Types.Int -> b -> b[OneShot] n1 :: b[OneShot] ->
                          GHC.Base.foldr @ GHC.Types.Int @ b c n1 preceding)
                         ms))) -}
c22c794e7bcd049bcafdbf877939d863
  parEpsilons ::
    [ConnectN.Move]
    -> [[ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ preceding :: [ConnectN.Move] ->
                 let {
                   poolOfMoves :: [GHC.Types.Int]
                   = Data.OldList.sortBy
                       @ GHC.Types.Int
                       GHC.Classes.compareInt
                       (Data.OldList.\\
                          @ GHC.Types.Int
                          GHC.Classes.$fEqInt
                          ConnectN.parEpsilons1
                          preceding)
                 } in
                 case GHC.List.$wlenAcc
                        @ GHC.Types.Int
                        poolOfMoves
                        0 of ww2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0 ww2) of wild {
                   GHC.Types.False
                   -> GHC.Types.[]
                        @ ([ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move)
                   GHC.Types.True
                   -> case GHC.List.$wlenAcc
                             @ GHC.Types.Int
                             preceding
                             0 of ww1 { DEFAULT ->
                      let {
                        epsilonO1 :: [GHC.Types.Int]
                                     -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int
                          {- Arity: 1, Strictness: <L,1*U> -}
                        = \ h :: [GHC.Types.Int] ->
                          let {
                            xs :: [GHC.Types.Int] = Logic.GameLogic.epsilons_go h poolOfMoves
                          } in
                          \ p1 :: GHC.Types.Int -> GHC.Types.Int ->
                          Logic.GameLogic.argsup
                            @ GHC.Types.Int
                            xs
                            (\ x1 :: GHC.Types.Int ->
                             case p1 x1 of wild1 { GHC.Types.I# x2 ->
                             GHC.Types.I# (GHC.Prim.negateInt# x2) })
                      } in
                      let {
                        epsilonX :: [GHC.Types.Int]
                                    -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int
                          {- Arity: 1, Strictness: <L,1*U>,
                             Unfolding: InlineRule (1, True, False)
                                        (\ h :: [GHC.Types.Int] ->
                                         Logic.GameLogic.argsup
                                           @ GHC.Types.Int
                                           (Logic.GameLogic.epsilons_go h poolOfMoves)) -}
                        = \ h :: [GHC.Types.Int] ->
                          Logic.GameLogic.argsup
                            @ GHC.Types.Int
                            (Logic.GameLogic.epsilons_go h poolOfMoves)
                      } in
                      letrec {
                        all :: [[GHC.Types.Int]
                                -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int]
                        = GHC.Types.:
                            @ ([GHC.Types.Int]
                               -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int)
                            epsilonX
                            a1
                        a1 :: [[GHC.Types.Int]
                               -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int]
                        = GHC.Types.:
                            @ ([GHC.Types.Int]
                               -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int)
                            epsilonO1
                            all
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww1 0) of wild1 {
                        GHC.Types.False
                        -> GHC.List.$wunsafeTake
                             @ ([ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move)
                             ww2
                             (ConnectN.$wunsafeDrop
                                @ ([GHC.Types.Int]
                                   -> Logic.GameLogic.J GHC.Types.Int GHC.Types.Int)
                                ww1
                                all)
                        GHC.Types.True
                        -> GHC.List.$wunsafeTake
                             @ ([ConnectN.Move] -> Logic.GameLogic.J ConnectN.R ConnectN.Move)
                             ww2
                             all } } } }) -}
a82661b017d6091bdfa1a6731b5137d9
  parEpsilons1 :: [GHC.Types.Int]
  {- Unfolding: (ConnectN.$wxs2 3) -}
80161c1086da82f65990a7248f5f2f5d
  parOptimalPlay :: [ConnectN.Move] -> [ConnectN.Move]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ moves :: [ConnectN.Move] ->
                 GHC.Base.++
                   @ GHC.Types.Int
                   moves
                   (Logic.GameLogic.bigotimes
                      @ ConnectN.Move
                      @ ConnectN.R
                      (ConnectN.parEpsilons moves)
                      (ConnectN.pPar moves))) -}
3c51f69730aaecf33a74d15d339b77cb
  parShowOptimalPlay :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                ConnectN.parShowOptimalPlay1
                  `cast`
                (Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
527e5ca024b17e97f4c9c553e3b813fe
  parShowOptimalPlay1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        ConnectN.parShowOptimalPlay6
                        GHC.Types.True
                        s of ds1 { (#,#) ipv ipv1 ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   ConnectN.parShowOptimalPlay2
                   GHC.Types.True
                   ipv }) -}
f6ebc3f2daf2b0d78cff6c77827869a8
  parShowOptimalPlay10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "x"#
                   ConnectN.parShowOptimalPlay11) -}
65bb071d3cb5675b1231ef0ab3b9da91
  parShowOptimalPlay11 :: [GHC.Types.Char]
  {- Unfolding: (case GHC.Show.$wshowSignedInt
                        0
                        3
                        (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                   ConnectN.parShowOptimalPlay12 }) -}
8ad6d6081810cb1feb088f81fbabd22a
  parShowOptimalPlay12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " grid;"#) -}
c45d5543d5ae4352ac26588036dc0255
  parShowOptimalPlay2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "X "#
                   ConnectN.parShowOptimalPlay3) -}
e42b7f91f87450c8c1d1b20e8c0ab3c1
  parShowOptimalPlay3 :: [GHC.Types.Char]
  {- Unfolding: (case ConnectN.$wvalue
                        ConnectN.parShowOptimalPlay5 of ww {
                   DEFAULT
                   -> GHC.CString.unpackAppendCString#
                        "lose"#
                        ConnectN.parShowOptimalPlay_n
                   0
                   -> GHC.CString.unpackAppendCString#
                        "draw"#
                        ConnectN.parShowOptimalPlay_n
                   1
                   -> GHC.CString.unpackAppendCString#
                        "win"#
                        ConnectN.parShowOptimalPlay_n }) -}
90b7322444a4199410b2975569045862
  parShowOptimalPlay4 :: GHC.Base.String
  {- Unfolding: (GHC.Show.showList__
                   @ GHC.Types.Int
                   GHC.Show.shows7
                   ConnectN.parShowOptimalPlay_optimalMoves
                   (GHC.Types.[] @ GHC.Types.Char)) -}
794877a5735deffa30f6c43bf643b972
  parShowOptimalPlay5 :: ConnectN.Board
  {- Unfolding: (ConnectN.movesToBoard_go
                   ConnectN.movesToBoard_players
                   ConnectN.parShowOptimalPlay_optimalMoves
                   (GHC.Types.[] @ ConnectN.Position)) -}
9ba51c1954e8ead3608544f53e2d7616
  parShowOptimalPlay6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "For a game of Connect"#
                   ConnectN.parShowOptimalPlay7) -}
dd33721f5406d1d4d5db5cfa622464fa
  parShowOptimalPlay7 :: [GHC.Types.Char]
  {- Unfolding: (case GHC.Show.$wshowSignedInt
                        0
                        3
                        (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                   ConnectN.parShowOptimalPlay8 }) -}
63dcfa61b288fb7633f05dbbd27b58b8
  parShowOptimalPlay8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   " on a "#
                   ConnectN.parShowOptimalPlay9) -}
0f0db0db3b6e6989840a3d5b730482ae
  parShowOptimalPlay9 :: [GHC.Types.Char]
  {- Unfolding: (case GHC.Show.$wshowSignedInt
                        0
                        3
                        (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                   ConnectN.parShowOptimalPlay10 }) -}
2fdb98fa75b9478780894c73c4a24f87
  parShowOptimalPlay_a4 ::
    [[ConnectN.Move]]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [[ConnectN.Move]] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
5941d9a499c72b63eb99cb2232a73f13
  parShowOptimalPlay_n :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "s : "#
                   ConnectN.parShowOptimalPlay4) -}
d284818ebe6064f5d0be4651116b1877
  parShowOptimalPlay_optimalMoves :: [ConnectN.Move]
  {- Unfolding: (case ConnectN.$wgo 1 of ww { (#,#) ww1 ww2 ->
                 case ConnectN.parShowOptimalPlay_a4
                        (GHC.Types.: @ [ConnectN.Move] ww1 ww2)
                        GHC.Prim.realWorld# of ds { (#,#) ipv ipv1 ->
                 Logic.GameLogic.argsup @ [ConnectN.Move] ipv1 ConnectN.p } }) -}
0592c60216eb9750667d18058b63bb27
  prettyPrint :: ConnectN.Board -> GHC.Base.String
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ b :: ConnectN.Board ->
                 letrec {
                   go3 :: [GHC.Types.Int]
                          -> [[(ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)]]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [GHC.Types.Int] ->
                     case ds of wild {
                       []
                       -> GHC.Types.[]
                            @ [(ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)]
                       : y ys
                       -> GHC.Types.:
                            @ [(ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)]
                            (letrec {
                               go4 :: [(ConnectN.X, GHC.Types.Int, ConnectN.Player)]
                                      -> [(ConnectN.X,
                                           GHC.Types.Int,
                                           GHC.Base.Maybe ConnectN.Player)]
                                 {- Arity: 1, Strictness: <S,1*U> -}
                               = \ ds1 :: [(ConnectN.X, GHC.Types.Int, ConnectN.Player)] ->
                                 case ds1 of wild1 {
                                   []
                                   -> GHC.Types.[]
                                        @ (ConnectN.X,
                                           GHC.Types.Int,
                                           GHC.Base.Maybe ConnectN.Player)
                                   : y1 ys1
                                   -> case y1 of wild2 { (,,) ds2 y' ds3 ->
                                      case y' of wild3 { GHC.Types.I# x1 ->
                                      case y of wild4 { GHC.Types.I# y2 ->
                                      case GHC.Prim.tagToEnum#
                                             @ GHC.Types.Bool
                                             (GHC.Prim.==# x1 y2) of wild5 {
                                        GHC.Types.False -> go4 ys1
                                        GHC.Types.True
                                        -> GHC.Types.:
                                             @ (ConnectN.X,
                                                GHC.Types.Int,
                                                GHC.Base.Maybe ConnectN.Player)
                                             (ds2, wild3, GHC.Base.Just @ ConnectN.Player ds3)
                                             (go4 ys1) } } } } }
                             } in
                             Data.OldList.sortBy
                               @ (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
                               ConnectN.prettyPrint_order
                               (Data.OldList.unionBy
                                  @ (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
                                  ConnectN.prettyPrint_isBlank
                                  (go4 b)
                                  (GHC.List.zip3
                                     @ ConnectN.X
                                     @ ConnectN.Y
                                     @ (GHC.Base.Maybe ConnectN.Player)
                                     ConnectN.prettyPrint7
                                     (GHC.List.repeat @ GHC.Types.Int y)
                                     ConnectN.prettyPrint_xs)))
                            (go3 ys) }
                 } in
                 case GHC.Base.map
                        @ [(ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)]
                        @ [GHC.Types.Char]
                        ConnectN.prettyPrint3
                        (GHC.List.reverse1
                           @ [(ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)]
                           (go3 ConnectN.prettyPrint7)
                           (GHC.Types.[]
                              @ [(ConnectN.X,
                                  ConnectN.Y,
                                  GHC.Base.Maybe ConnectN.Player)])) of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : x1 xs1
                   -> Data.OldList.intercalate_$spoly_go
                        @ GHC.Types.Char
                        x1
                        (Data.OldList.prependToAll
                           @ [GHC.Types.Char]
                           ConnectN.prettyPrint1
                           xs1) }) -}
7ed944a8a57c3bb7a613b3cd98df9340
  prettyPrint1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "\n"#
                   ConnectN.prettyPrint2) -}
6d116cd2a96384c7e2d7c9f807806487
  prettyPrint2 :: [GHC.Types.Char]
  {- Unfolding: (ConnectN.$wxs3 3) -}
355d6fccbbca7722bd23a8cfa09821a9
  prettyPrint3 ::
    [(ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)]
    -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ x1 :: [(ConnectN.X,
                           ConnectN.Y,
                           GHC.Base.Maybe ConnectN.Player)] ->
                 GHC.CString.unpackAppendCString#
                   "  "#
                   (case GHC.Base.map
                           @ (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
                           @ [GHC.Types.Char]
                           ConnectN.prettyPrint5
                           x1 of wild {
                      [] -> GHC.Types.[] @ GHC.Types.Char
                      : x2 xs1
                      -> Data.OldList.intercalate_$spoly_go
                           @ GHC.Types.Char
                           x2
                           (Data.OldList.prependToAll
                              @ [GHC.Types.Char]
                              ConnectN.prettyPrint4
                              xs1) })) -}
a40c81aa58938617c0fa6177ee9499b4
  prettyPrint4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " | "#) -}
7e06f1f7035cb83c799884f2d616c255
  prettyPrint5 ::
    (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
    -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: (ConnectN.X,
                          ConnectN.Y,
                          GHC.Base.Maybe ConnectN.Player) ->
                 case ds of wild { (,,) ds1 ds2 p1 ->
                 case p1 of wild1 {
                   GHC.Base.Nothing -> ConnectN.prettyPrint6
                   GHC.Base.Just x1
                   -> case x1 of wild2 {
                        ConnectN.X -> ConnectN.$fReadPlayer11
                        ConnectN.O -> ConnectN.$fReadPlayer8 } } }) -}
15dc274c4784c8a6b12e724adc3f91d3
  prettyPrint6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " "#) -}
103517e793502b22bdcbce81d71b0c9b
  prettyPrint7 :: [GHC.Types.Int]
  {- Unfolding: (GHC.Enum.eftInt 1 3) -}
e8003198f535c835c8ee7bf98c3d8155
  prettyPrint_isBlank ::
    (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
    -> (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U(U),1*U(U),A)><S(SLL),1*U(1*U(U),1*U(U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
                   w1 :: (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player) ->
                 case w of ww { (,,) ww1 ww2 ww3 ->
                 case ww1 of ww4 { GHC.Types.I# ww5 ->
                 case w1 of ww6 { (,,) ww7 ww8 ww9 ->
                 case ww7 of ww10 { GHC.Types.I# ww11 ->
                 ConnectN.$wisBlank ww5 ww2 ww11 ww8 ww9 } } } }) -}
050cbc32e7629914d09b1dfd4fd3038a
  prettyPrint_order ::
    (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
    -> (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
    -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U(U),A,A)><S(SLL),1*U(1*U(U),A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player)
                   ds1 :: (ConnectN.X, ConnectN.Y, GHC.Base.Maybe ConnectN.Player) ->
                 case ds of wild { (,,) x1 ds2 ds3 ->
                 case ds1 of wild1 { (,,) x' ds4 ds5 ->
                 GHC.Classes.compareInt x1 x' } }) -}
2fb0a1783dc1a2d27ea06ef772926ea4
  prettyPrint_xs :: [GHC.Base.Maybe ConnectN.Player]
  {- HasNoCafRefs, Strictness: m2 -}
e554d5cc608982cc5ebedb8d749fe5e5
  showOptimalPlay :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                ConnectN.showOptimalPlay1
                  `cast`
                (Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
514f556b79369e3dfb868d4ddf1fdfab
  showOptimalPlay1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (GHC.Show.$fShow[]_$s$cshow ConnectN.optimalPlay)
                   GHC.Types.True
                   eta) -}
936ddc333c8d465e6f544637a4dfa69d
  takeTurn ::
    ConnectN.Player
    -> ConnectN.Move -> ConnectN.Board -> ConnectN.Board
  {- Arity: 3, Strictness: <L,U><L,U(U)><S,U>,
     Unfolding: (\ p1 :: ConnectN.Player
                   m :: ConnectN.Move
                   b :: ConnectN.Board ->
                 letrec {
                   $wgo1 :: [(ConnectN.Move, ConnectN.Y, ConnectN.Player)]
                            -> GHC.Prim.Int# -> GHC.Prim.Int#
                     {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                   = \ w :: [(ConnectN.Move, ConnectN.Y, ConnectN.Player)]
                       ww :: GHC.Prim.Int# ->
                     case w of wild {
                       [] -> ww
                       : y ys
                       -> case y of wild1 { (,,) x1 ds ds1 ->
                          case x1 of wild2 { GHC.Types.I# x2 ->
                          case m of wild3 { GHC.Types.I# y1 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.==# x2 y1) of wild4 {
                            GHC.Types.False -> $wgo1 ys ww
                            GHC.Types.True -> $wgo1 ys (GHC.Prim.+# ww 1) } } } } }
                 } in
                 case $wgo1 b 0 of ww { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww 3) of wild {
                   GHC.Types.False -> ConnectN.takeTurn1 m b
                   GHC.Types.True
                   -> GHC.Base.++
                        @ (ConnectN.X, ConnectN.Y, ConnectN.Player)
                        b
                        (GHC.Types.:
                           @ (ConnectN.X, ConnectN.Y, ConnectN.Player)
                           (m, GHC.Types.I# (GHC.Prim.+# ww 1), p1)
                           (GHC.Types.[] @ (ConnectN.X, ConnectN.Y, ConnectN.Player))) } }) -}
4045c66e5a488b1ea622a5398ace5ce9
  takeTurn1 :: ConnectN.Move -> ConnectN.Board -> ConnectN.Board
  {- Arity: 2, Strictness: <L,U><L,U>b -}
254abee85fcd368b524c32cd5719f562
  value :: ConnectN.Board -> ConnectN.R
  {- Arity: 1, Strictness: <L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: ConnectN.Board ->
                 case ConnectN.$wvalue w of ww { DEFAULT -> GHC.Types.I# ww }) -}
3315d90f8988227d99e672bc09bb82c0
  width :: GHC.Types.Int
  {- Strictness: m, Unfolding: (ConnectN.height) -}
5569e1eee68e4618133c161afeeb2708
  winningAmount :: GHC.Types.Int
  {- Strictness: m, Unfolding: (ConnectN.height) -}
aad04a3a5213b0053e6225c30aa34f3a
  wins :: ConnectN.Player -> ConnectN.Board -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><L,U> -}
instance GHC.Classes.Eq [ConnectN.Player] = ConnectN.$fEqPlayer
instance GHC.Classes.Ord [ConnectN.Player] = ConnectN.$fOrdPlayer
instance GHC.Read.Read [ConnectN.Player] = ConnectN.$fReadPlayer
instance GHC.Show.Show [ConnectN.Player] = ConnectN.$fShowPlayer
"SPEC argmax @ Int" [ALWAYS] forall $dNFData :: Control.DeepSeq.NFData
                                                  GHC.Types.Int
                                    $dOrd :: GHC.Classes.Ord GHC.Types.Int
  ConnectN.argmax @ GHC.Types.Int $dNFData $dOrd
  = ConnectN.argmax_$sargmax
"SPEC argmin @ Int" [ALWAYS] forall $dNFData :: Control.DeepSeq.NFData
                                                  GHC.Types.Int
                                    $dOrd :: GHC.Classes.Ord GHC.Types.Int
  ConnectN.argmin @ GHC.Types.Int $dNFData $dOrd
  = ConnectN.argmin_$sargmin
"SPEC/ConnectN $dmreadsPrec @ Player" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                  ConnectN.Player
  GHC.Read.$dmreadsPrec @ ConnectN.Player $dRead
  = ConnectN.$fReadPlayer_$s$dmreadsPrec
"SPEC/ConnectN readListDefault @ Player" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                     ConnectN.Player
  GHC.Read.readListDefault @ ConnectN.Player $dRead
  = ConnectN.$fReadPlayer_$sreadListDefault
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

